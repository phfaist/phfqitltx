% \iffalse meta-comment
%
% Copyright (C) 2016 by Philippe Faist <philippe.faist@bluewin.ch>
% -------------------------------------------------------
% 
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
%    http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX 
% version 2005/12/01 or later.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{phfthm.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[2005/12/01]
%<package>\ProvidesPackage{phfthm}
%<*package>
    [2016/05/13 v1.0 phfthm package]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{xcolor}
\usepackage{phfthm}
\usepackage[preset=xpkgdoc]{phfnote}
\EnableCrossrefs         
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{phfthm.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v1.0}{2016/04/20}{Initial version}
%
% \GetFileInfo{phfthm.dtx}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\gdef,\edef,\xdef,\if,\else,\fi,\ifx}
% \DoNotIndex{\expandafter,\csname,\endcsname,\let}
% 
% \title{The \pkgname{phfthm} package\thanks{\itshape
% This document corresponds to
% \pkgname{phfthm}~\fileversion, dated \filedate. It is part of
% the Part of the
% \href{https://github.com/phfaist/phfqitltx/}{\pkgname{phfqitltx}}
% package suite, see \url{https://github.com/phfaist/phfqitltx}.}}
% \author{Philippe Faist\quad\email{philippe.faist@bluewin.ch}}
%
% \maketitle
%
% \begin{abstract}
%   \pkgname{phfthm}---Goodies for theorems and proofs.
% \end{abstract}
%
% \inlinetoc
%
% \section{Introduction}
%
% The \pkgname{phfthm} package provides enhanced theorem and proof environments,
% based on the \pkgname{amsthm} original versions.  It allows for hooks to be
% placed, adds some default goodies and is highly customizable.
%
% There are three generic types of environments provided: theorem environments,
% proof environments and ``thmheading'' environments.
%
% \section{Theorem environments}
%
% A theorem environment is based on the environment furnished by
% \pkgname{amsthm}'s |\newtheorem| command, but with added goodies.
%
% \subsection{Presets: predefined theorem sets}
%
% .........
%
% \subsection{Define theorem environments manually}
%
% ......... Using |\phfMakeTheorem|....
%
% \subsection{Theorem hooks}
% \label{sec:theorem-hooks}
%
% Any theorem environment automatically calls some hooks.  There are hooks
% available per theorem environment as well as generic for all theorem
% environments.
%
% \DescribeMacro{\phfthm@hook@start@<thmname>} The hook
% |\phfthm@hook@start@|\meta{theorem environment name}\marg{theorem title} is
% called at the start of the environment.  More precisely, it is called inside
% the original \pkgname{amsthm} base environment; that is, after the heading was
% generated.  It takes one mandatory argument, the optional title provided to
% the theorem environment which may be empty.  By default, the hook defers to
% the global hook |\phfthm@hook@startcommonnostar|.
%
% \DescribeMacro{\phfthm@hook@start@<thmname>*} The hook
% |\phfthm@hook@start@|\meta{starred theorem environment name} is completely
% analogous, and is called for the starred environment.  The only difference is
% that by default, it defers its call to |\phfthm@hook@startcommonstar|.
%
% \DescribeMacro{\phfthm@hook@startcommonnostar} The hook
% |\phfthm@hook@startcommonnostar|\marg{theorem environment name}\marg{theorem
% optional given title} collects the default definitions for non-starred
% environments (such as overriding the |\label| command to generate appropriate
% proof-refs), and continues to defer to
% \DescribeMacro{\phfthm@hook@startcommon}
% |\phfthm@hook@startcommon|\marg{theorem environment name}\marg{theorem
% optional given title}.  \DescribeMacro{\phfthm@hook@startcommonstar}
% Analogously, the macro |\phfthm@hook@startcommonstar|\marg{theorem environment
% name}\marg{theorem optional given title} groups commands for starred
% environments (typically doesn't take care of |\label| stuff) and also defers
% to |\phfthm@hook@startcommon|.
%
% By default, the |\phfthm@hook@startcommonnostar| introduces definitions for
% overriding the |\label| command (via a call to
% |\phfthm@def@label@thmlabel|\marg{theorem environment name}).  If this
% behavior is not overridden, then the |\label| command is redefined so that at
% its fist occurrence, it provides the theorem environment label to use for the
% proof reference (``see proof on page \ldots'', see
% \autoref{sec:proof-ref-mechanism}).  There, an additional hook is provided,
% \DescribeMacro{\phfthm@hook@afterlabel@<thmname>}
% |\phfthm@hook@afterlabel@|\meta{theorem environment name}, which is called
% after the theorem label is set (it can be recovered from the value of
% |\phfthm@val@thmlabel|.  By default, that hook calls the common hook
% |\phfthm@hook@afterlabelcommon|\marg{theorem environment name}. (After the
% first occurrence of |\label|, its definition is restored.)
%
%
% The end hooks work very much
% analogously. \DescribeMacro{\phfthm@hook@end@<thmname>}
% |\phfthm@hook@end@|\meta{theorem environment name} and
% \DescribeMacro{\phfthm@hook@end@<thmname>*} |\phfthm@hook@end@|\meta{starred
% theorem environment name} are called respectively for the non-starred and
% starred version of that theorem environment, and by default they defer to the
% common \DescribeMacro{\phfthm@hook@endcommonnostar}
% |\phfthm@hook@endcommonnostar|\marg{theorem environment name} or
% \DescribeMacro{\phfthm@hook@endcommonstar}
% |\phfthm@hook@endcommonstar|\marg{theorem environment name}.  Both these hooks
% defer their calls to |\phfthm@hook@endcommon|\marg{theorem environment name}.
%
%
% \section{Definitions for proof environments}
%
% \subsection{Manually define a proof environment}
% \label{sec:mk-proof-env}
%
% ......... Using |\phfMakeProofEnv|....
%
% Options:
% \begin{cmdoptions}
% \item[displayenv=\meta{name of \LaTeX{} environment}] Set a
%   \LaTeX{} environment to use to actually format and display the proof.  (The
%   |\phfMakeProofEnv| command itself doesn't care about how the proof is
%   displayed or formatted; rather it adds a goodies infrastructure in which
%   stuff can be plugged in and provides options for such goodies.)
%
%   You may specify here the name of a \LaTeX{} environment, or give the special
%   value \cmdoptionfmt{displayenv=*} to indicate the default appearance
%   provided by \pkgname{phfthm}, or leave the value empty
%   \cmdoptionfmt{displayenv=} to signify that no underlying display environment
%   should be invoked.  (The latter may be useful if you are plugging a
%   |\phfMakeProofEnv|-generated environment into a larger environment which
%   already takes care of the display.)
%
% \item[defaultproofname=\meta{default proof title}] Specify here the title to
%   use (e.g.\@ ``Proof'') if no argument was given to the proof environment.
%   If you do not specify any |defaultproofname|, or pass an empty value, then
%   the value of |\proofname| is used.
%
% \item[parselabel=\meta{\phfverb{true} $\mid$ \phfverb{false}}] Specify whether
%   the environment should parse its argument for some special information.  If
%   set to |true|, then the proof argument is passed on to a command (specified
%   by the \cmdoptionfmt{parselabelcmd} option).
%
% \item[parselabelcmd=\meta{{\LaTeX} macro}] If \cmdoptionfmt{parselabel} is set
%   to |true|, then specify here a \LaTeX{} command which parses whatever it
%   wants from the proof environment's argument.  The macro should set the
%   |\phfthm@val@displayargs| macro to tokens which will be expanded just after
%   the invocation of the proof environment's display environment
%   (\cmdoptionfmt{displayenv}). It should also set |\phfthm@val@proofoflabel|
%   (if appropriate) to the label corresponding to the theorem for which this is
%   the proof of.
%
%   By default, the command |\phfthm@proof@parselabel| is used, which parses the
%   proof environment's argument for a reference to a theorem in the context of
%   a proof-ref mechanism (see \autoref{sec:proof-ref-mechanism}).  The label is
%   parsed to see if it is of the form |[*thm:reference]|, where |thm:reference|
%   is the label pinned to a theorem.
%
% \item[override=\meta{\phfverb{true} $\mid$ \phfverb{false}}] Whether to
%   override any existing environment with the same name as the new proof
%   environment. If |true| is specified here, then |\renewenvironment| is used
%   to define the proof environment, otherwise a simple |\newenvironment| is
%   used.
%
% \item[internalcounter=\meta{name of \LaTeX{} counter}] The name of the
%   internal counter the proof environment should use.  The count number is not
%   displayed (by default at least), but it is only used to pin down anchors for
%   PDF hyperlinks.
%
%   The counter should already be defined with |\newcounter|.
%
% \item[proofofname=\meta{\LaTeX{} macro}] Specify here a macro
%   which will be called with a single argument. The macro produces the text to
%   display when the proof environment is parsed as the proof of a specific
%   theorem or proposition (or other theorem environment).  The argument which
%   will be given to it is the title of what the proof is of (e.g.\@ ``Theorem
%   3''). Typically, the macro should produce something like ``Proof of Theorem
%   XYZ.''
%
%   By default, the macro |\proofofname| is used.
% \end{cmdoptions}
%
% \subsection{Proof hooks}
% \label{sec:proof-hooks}
% xxxxxxx..............
%
% \section{Pairing theorems to proofs and proof-ref mechanism}
% \label{sec:proof-ref-mechanism}
%
% One of the goodies provided by the \pkgname{phfthm} package is the proof-ref
% mechanism, where in a theorem environment, the text ``see proof on page
% \ldots'' is displayed to direct the reader to the location of the
% corresponding proof.  The mechanism is deactivated by default, but can be
% enabled with a simple package option.
%
% This only works if the proof is given the label of the corresponding theorem
% or proposition.  For example:
% \begin{verbatim}
% \begin{theorem}[Gauss]
%   \label{thm:Gauss}
%   For a closed surface $S$ enclosing a volume $V$, we have
%   \begin{equation}
%     \oint_S\vec u\cdot d\vec S = \int_V(\vec\nabla\cdot\vec u)\,dV\ .
%   \end{equation}
% \end{theorem}
%
% ...
%
% \begin{proof}[*thm:Gauss]
%   ...
% \end{proof}
% \end{verbatim}
%
% The above example might produce the following output:
% \begingroup\setlength{\fboxsep}{1em}
% \par\noindent\fbox{
%   \begin{minipage}{\dimexpr\textwidth-2\fboxsep-2\fboxrule\relax}
%     \textbf{Theorem 17} (Gauss). For a closed surface $S$ enclosing a
%     volume $V$, we have
%     \setcounter{equation}{41}
%     \begin{equation}
%       \oint_S\vec u\cdot d\vec S = \int_V(\vec\nabla\cdot\vec u)\,dV\ .
%     \end{equation}
%     \hfill{\small\itshape (Proof on page XXX.)}\hfilneg
%     {\par\vspace{1ex}\relax
%     \ldots\par\vspace{1ex}}\relax
%     \par\textit{Proof of Theorem 17.}\hspace{2em}\ldots
%   \end{minipage}
% }\endgroup
%
%
%
% \StopEventually{\PrintChangesAndIndex}
%
%
%
% \section{Implementation}
%
% First, load some packages.  General toolboxes:
%    \begin{macrocode}
\RequirePackage{xkeyval}
\RequirePackage{etoolbox}
%    \end{macrocode}
% 
% To define alias counters for theorems, load \pkgname{aliascnt}:
%    \begin{macrocode}
\RequirePackage{aliascnt}
%    \end{macrocode}
% 
% And finally, load the \textit{AMS} math and theorem (\pkgname{amsmath},
% \pkgname{amsthm}) packages:
%    \begin{macrocode}
\RequirePackage{amsmath}
\RequirePackage{amsthm}
%    \end{macrocode}
% 
%
% \subsection{Generic Internal Stuff}
%
% \begin{macro}{\phfthm@internal@execattribs}
%
%   Internal command: execute all definitions given in list of attributes.  This was
%   copy-pasted from a similar definition in the \pkgname{phfnote} package.
%
%   |#1| = prefix to look for attributes
%   
%   |#2| = name of what |#1| represents, to use in message in case attribute is not found
%   
%   |#3| = list of attributes
%
%    \begin{macrocode}
\def\phfthm@internal@execattribs#1#2#3{%
  \@for\next:=#3\do{%
    \ifcsname #1\next\endcsname%
      \csname #1\next\endcsname%
    \else%
      \PackageWarning{phfthm}{Unknown #2: '\next'. Ignoring.}
    \fi
  }
}
%    \end{macrocode}
% \end{macro}
% 
%
% \subsection{Definitions for theorem environments}
%
% \subsubsection{\phfverb{\phfMakeTheorem}: definition of a new theorem environment}
%
% First, define some key-value syntax accepted by the |\phfMakeTheorem| command.
%    \begin{macrocode}
\define@cmdkey{phfmkthm}{counter}{}
\define@boolkey{phfmkthm}{aliascounter}[true]{}
\define@cmdkey{phfmkthm}{thmstyle}{}
\define@boolkey{phfmkthm}{defnostar}[true]{} % define {thm} variant
\define@boolkey{phfmkthm}{defstar}[true]{} % define {thm*} variant
%    \end{macrocode}
% 
% \begin{macro}{\phfMakeTheorem}
%   Define a new theorem environment.  The syntax is
%   |\phfMakeTheorem|\hspace{0pt}\oarg{options}\hspace{0pt}\marg{theorem
%   environment name}\hspace{0pt}\marg{Theorem Display Name}.  For example:
%   |\phfMakeTheorem[counter=thmcounter]{prop}{Proposition}|
%    \begin{macrocode}
\newcommand\phfMakeTheorem[3][]{%
%    \end{macrocode}
% \iffalse meta-comment %} -- for emacs' paren matching
% \fi
% Handle the [options].  First, ensure that the defaults are set, and then, parse the input.
%    \begin{macrocode}
  \KV@phfmkthm@aliascountertrue%
  \def\cmdKV@phfmkthm@counter{}%
  \def\cmdKV@phfmkthm@thmstyle{}%
  \KV@phfmkthm@defnostartrue%
  \KV@phfmkthm@defstartrue%
  \setkeys{phfmkthm}{#1}%
%    \end{macrocode}
% 
% Now, react to whatever was given in the options.
%
% \verbdef\tmptheifconstruct|\if\relax\detokenize{...}\relax|
% Set the theorem style, if requested.\footnote{The construct
% \tmptheifconstruct\space tests whether \phfverb{...} is empty: see
% \url{http://tex.stackexchange.com/a/53091/32188}}
%    \begin{macrocode}
  \if\relax\detokenize\expandafter{\cmdKV@phfmkthm@thmstyle}\relax%
  \else%
    \theoremstyle{\cmdKV@phfmkthm@thmstyle}%
  \fi%
%    \end{macrocode}
% 
% If requested, define the default, unstarred version of the theorem.  Use
% |\newtheorem| for that, which we make sure to call appropriately depending on
% whether a separate counter is requested or not.  Make sure also to define
% |\...autorefname| for |\autoref|.  If an alias counter is requested, create it
% and pass that one to |\newtheorem|.
%
% At this point, we create a theorem named |phfthm@....|, because we still want
% to add calls to hooks.
%    \begin{macrocode}
  \ifKV@phfmkthm@defnostar%
    \if\relax\detokenize\expandafter{\cmdKV@phfmkthm@counter}\relax%
%    \end{macrocode}
% ---in case we use our own separate counter:
%    \begin{macrocode}
      \newtheorem{phfthm@#2}{#3}%
      \csdef{phfthm@#2autorefname}{#3}%
    \else%
      \ifKV@phfmkthm@aliascounter%
%    \end{macrocode}
% ---in case we make a distinct alias counter, eg. for use with |\autoref|:
%    \begin{macrocode}
        \newaliascnt{#2}{\cmdKV@phfmkthm@counter}%
        \newtheorem{phfthm@#2}[#2]{#3}%
        \aliascntresetthe{#2}%
        \csdef{#2autorefname}{#3}%
      \else%
%    \end{macrocode}
% ---in case we directly instruct |\newtheorem| to use the other counter (does not work with |\autoref|):
%    \begin{macrocode}
        \newtheorem{phfthm@#2}[\cmdKV@phfmkthm@counter]{#3}%
      \fi%
    \fi%
%    \end{macrocode}
%
% And also define the actual theorem environment, adding calls to hooks.
%    \begin{macrocode}
    \newenvironment{#2}[1][]{%
      \begin{phfthm@#2}[##1]%
        \begingroup%
          \csname phfthm@hook@start@#2\endcsname{##1}%
      }{%
          \csname phfthm@hook@end@#2\endcsname%
        \endgroup%
      \end{phfthm@#2}%
    }%
%    \end{macrocode}
% Define hooks specific to this theorem with sensible defaults: call common
% hooks (see |\phfthm@hook@startcommonnostar|, |\phfthm@hook@afterlabelcommon|
% and |\phfthm@hook@endcommonnostar|, detailed in \autoref{sec:theorem-hooks}).
%    \begin{macrocode}
    \csdef{phfthm@hook@start@#2}##1{\phfthm@hook@startcommonnostar{#2}{##1}}%
    \csdef{phfthm@hook@afterlabel@#2}{\phfthm@hook@afterlabelcommon{#2}}%
    \csdef{phfthm@hook@end@#2}{\phfthm@hook@endcommonnostar{#2}}%
  \fi%
%    \end{macrocode}
% 
%
% If requested, define the starred version of the theorem.  We call
% |\newtheorem*| to define the base theorem environment (which we call
% |phfthm@....|), after which as above we define the actual environment which
% also calls the relevant hooks.
%    \begin{macrocode}
  \ifKV@phfmkthm@defstar%
    \newtheorem*{phfthm@#2*}{#3}%
    \newenvironment{#2*}[1][]{%
      \begin{phfthm@#2*}[##1]%
        \begingroup%
          \csname phfthm@hook@start@#2*\endcsname{##1}%
      }{%
          \csname phfthm@hook@end@#2*\endcsname%
        \endgroup%
      \end{phfthm@#2*}%
    }%
  \fi%
%    \end{macrocode}
% 
% Finally, define the default hooks specific to the starred version of the
% theorem (see \autoref{sec:theorem-hooks}).
%    \begin{macrocode}
  \csdef{phfthm@hook@start@#2*}##1{\phfthm@hook@startcommonstar{#2}{##1}}%
  \csdef{phfthm@hook@end@#2*}{\phfthm@hook@endcommonstar{#2}}%
}
%    \end{macrocode}
% \end{macro}
% 
%
% \subsubsection{Default hooks for theorems}
%
% \begin{macro}{\phfthm@hook@startcommonnostar}
% \begin{macro}{\phfthm@hook@startcommonstar}
% \begin{macro}{\phfthm@hook@startcommon}
% Common default hooks definitions for start of the theorems.
%
% For all three of these hooks, we have
% |#1| = theorem name, e.g. |proposition| and 
% |#2| = full (optional) title of proposition, if given, or empty.
%
% Make sure to invoke the |\label| re-definition hack only for non-starred
% theorems/propositions; indeed, if no theorem label is set we don't want to
% interfere with labels set to inner equations, itemizes etc.  Hence, call
% |\phfhtm@def@label@thmlabel| only in the ``nostar'' hook.
%    \begin{macrocode}
\def\phfthm@hook@startcommonnostar#1#2{%
  \phfthm@hook@startcommon{#1}{#2}%
  \phfthm@def@label@thmlabel{#1}%
}
\def\phfthm@hook@startcommonstar#1#2{%
  \phfthm@hook@startcommon{#1}{#2}%
}
\def\phfthm@hook@startcommon#1#2{%
%    \end{macrocode}
% Furthermore, in any case, set the |\postdisplaypenalty| to avoid an orphan
% line on a new page after display equation.
%    \begin{macrocode}
  \postdisplaypenalty=10000\relax%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\phfthm@hook@afterlabelcommon}
% \begin{macro}{\phfthm@hook@endcommonnostar}
% \begin{macro}{\phfthm@hook@endcommonstar}
% \begin{macro}{\phfthm@hook@endcommon}
%   Further hooks, for after the theorem main |\label| command
%   (|\phfthm@hook@@afterlabelcommon|) and for the end of the theorem.
%    \begin{macrocode}
\def\phfthm@hook@afterlabelcommon#1{}
\def\phfthm@hook@endcommonnostar#1{\phfthm@hook@endcommon{#1}}
\def\phfthm@hook@endcommonstar#1{\phfthm@hook@endcommon{#1}}
\def\phfthm@hook@endcommon#1{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsubsection{Proof-ref mechanism (on the theorem side)}
%
% These macros enable the proof-ref mechanism
% (\autoref{sec:proof-ref-mechanism}).  The theorem's label is stored upon
% calling |\label|, because we (locally) hack into the definition of |\label|.
% (After the first usage of |\label| its meaning is restored.)
% \begin{macro}{\phfthm@def@label@thmlabel}
%   Main macro to invoke at the beginning of the theorem environment, so that
%   the theorem label is stored in a local macro once |\label| is invoked.  This
%   hacks the |\label| macro locally.  Here, |#1| = the theorem environment
%   name, e.g.\@ |proposition|.
%    \begin{macrocode}
\def\phfthm@def@label@thmlabel#1{%
  \let\phfthm@old@label\label%
  \def\label{\phfthm@thmlabel{#1}}%
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\phfthm@thmlabel}
%   The macro which is invoked upon the first call to |\label| within the
%   theorem (for which |\phfthm@def@label@thmlabel| was called, which is the
%   default).
%
%   Here |#1| = theorem environment name, e.g.\@ |proposition|; and |#2| = the
%   label value (argument to the |\label| macro).
%    \begin{macrocode}
\def\phfthm@thmlabel#1#2{%
%    \end{macrocode}
% First, store the label value into a macro called |\phfthm@val@thmlabel|.
%    \begin{macrocode}
  \def\phfthm@val@thmlabel{#2}%
%    \end{macrocode}
% Then, call the original |\label| macro to do what \LaTeX\space would normally
% do for a |\label{|\ldots|}| call.
%    \begin{macrocode}
  \phfthm@old@label{#2}%
%    \end{macrocode}
% Invoke the |\phfthm@hook@afterlabel@<thmname>| hook for this theorem
% environment.
%    \begin{macrocode}
  \csname phfthm@hook@afterlabel@#1\endcsname%
%    \end{macrocode}
% Restore the old |\label| definition, in case there are other items in the
% theorem environment such as equations, itemizes etc.\@ which may themselves
% have |\label|'s.
%    \begin{macrocode}
  \let\label\phfthm@old@label%
%    \end{macrocode}
% Finally, ignore any spaces following the |\label| command. (Maybe we should
% have done something with |\@bsphack| and |\@esphack| but oh well\ldots
%    \begin{macrocode}
  \ignorespaces%
}
%    \end{macrocode}
% \end{macro}
% 
%
% \subsection{Definitions for proof environments}
%
% Improved, smarter |proof| environments.
%
% \begin{macro}{\phfthm@old@proof}
% \begin{macro}{\endphfthm@old@proof}
%   Save old |proof| environment provided by \pkgname{amsthm}.
%    \begin{macrocode}
\let\phfthm@old@proof\proof
\let\endphfthm@old@proof\endproof
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\proofname}
% And provide a default name for proofs (this should normally already be
% provided by \pkgname{amsthm}).
%    \begin{macrocode}
\providecommand\proofname{Proof}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\proofofname}
%   Default text to display when we want to say e.g.\@ ``Proof of Theorem 3.''
%    \begin{macrocode}
\def\proofofname#1{\proofname\space of #1}
%    \end{macrocode}
% \end{macro}
%
% The default counter for proofs.  The value of this counter is typically not
% displayed, we just use it to pin down anchors for labels for cross references.
%    \begin{macrocode}
\newcounter{phfthmproofcnt}
%    \end{macrocode}
% 
% Utility: to see if an argument was specified (possibly empty) to the proof
% environment.
%    \begin{macrocode}
\def\phfthm@NOPROOFARG{}
\def\phfthm@test@NOPROOFARG{\phfthm@NOPROOFARG}
%    \end{macrocode}
% 
% \subsubsection{Define a proof environment: \phfverb{\phfMakeProofEnv}}
%
% Declare some key-value options accepted by |\phfMakeProofEnv|.  See
% \autoref{sec:mk-proof-env} for the documentation of these options.
%    \begin{macrocode}
\define@cmdkey{phfmkprf}{displayenv}{}
\define@cmdkey{phfmkprf}{defaultproofname}{}
\define@boolkey{phfmkprf}{override}[true]{}
\define@cmdkey{phfmkprf}{internalcounter}{}
\define@cmdkey{phfmkprf}{proofofname}{}
\define@boolkey{phfmkprf}{parselabel}[true]{}
\define@cmdkey{phfmkprf}{parselabelcmd}{}
%    \end{macrocode}
%
% \begin{macro}{\phfMakeProofEnv}
%   Make a proof environment. Syntax:
%   |\phfMakeProofEnv|\hspace{0pt}\oarg{options}\hspace{0pt}\marg{proof
%   environment name}.
%    \begin{macrocode}
\newcommand\phfMakeProofEnv[2][]{%
%    \end{macrocode}
% \iffalse meta-comment %} -- for emacs' paren matching
% \fi
%
% Parse the key-value options.  First, make sure that all the defaults are set,
% then parse the options.
%    \begin{macrocode}
  \KV@phfmkprf@overridefalse%
  \def\cmdKV@phfmkprf@displayenv{*}%
  \def\cmdKV@phfmkprf@defaultproofname{\proofname}%
  \def\cmdKV@phfmkprf@internalcounter{phfthmproofcnt}%
  \def\cmdKV@phfmkprf@proofofname{\proofofname}%
  \KV@phfmkprf@parselabeltrue
  \def\cmdKV@phfmkprf@parselabelcmd{\phfthm@proof@parselabel}%
  \setkeys{phfmkprf}{#1}%
%    \end{macrocode}
% 
% The meaning of the options are detailed in \autoref{sec:mk-proof-env}.
% 
% The general idea here is first to pre-process all the options, and save all
% the useful information in macros named
% |\phfthm@prfenv@<proof-environment-name>@val@<something>|.  Then, we can define
% the begin/end environment macros which will recall the saved information.
%
% Take care of the display environment to use.  Recall that if |displayenv=*|,
% we use our own default; if |displayenv=| (empty), there is no display
% environment.  Here, we set
% |\phfthm@prfenv@<proof-environment-name>@val@displayenv| to the name of the
% environment to use (possibly empty), for later reference.
%    \begin{macrocode}
  \def\phfmkprf@tmp@star{*}%
  \ifx\cmdKV@phfmkprf@displayenv\phfmkprf@tmp@star\relax%
    \def\cmdKV@phfmkprf@displayenv{phfthm@proof@defaultdisplayenv}%
  \fi
  \cslet{phfthm@prfenv@#2@val@displayenv}\cmdKV@phfmkprf@displayenv%
%    \end{macrocode}
% 
% Process the default proof name.  If none is given, use |\proofname| and pass
% no option to the underlying display environment whenever the proof environment
% is called with no option.  Here, we set
% |\phfthm@prfenv@<proof-environment-name>@val@defaultproofnameargs| and
% |\phfthm@prfenv@<proof-environment-name>@val@setdefaultprooftitle|; the former
% is the tokens to put in front of the proof environment invocation in case no
% explicit proof title is given to the proof environment while the latter
% contains the command to set |\phfthm@val@prooftitle| to the default proof
% name.
%    \begin{macrocode}
  \if\relax\detokenize\expandafter{\cmdKV@phfmkprf@defaultproofname}\relax%
    \csdef{phfthm@prfenv@#2@val@defaultproofnameargs}{}%
    \csdef{phfthm@prfenv@#2@val@setdefaultprooftitle}{%
      \def\phfthm@val@prooftitle{\proofname}}%
  \else
    \csedef{phfthm@prfenv@#2@val@defaultproofnameargs}{%
      [\expandonce{\cmdKV@phfmkprf@defaultproofname}]}%
    \csedef{phfthm@prfenv@#2@val@setdefaultprooftitle}{%
      \noexpand\def\noexpand\phfthm@val@prooftitle{%
        \expandonce{\cmdKV@phfmkprf@defaultproofname}}}%
  \fi
  \csedef{phfthm@prfenv@#2@val@parselabelandmkdisplayargs}##1{%
    \ifKV@phfmkprf@parselabel
      \expandonce\cmdKV@phfmkprf@parselabelcmd{##1}%
    \else
      \noexpand\phfthm@proof@noparselabel{##1}%
    \fi
    \noexpand\def\noexpand\phfthm@val@displayargs{[{%
        \expandafter\noexpand\csname phfthm@prfenv@#2@val@proofofname\endcsname
        {\noexpand\phfthm@val@prooftitle}%
      }]}%
  }
%    \end{macrocode}
% 
% Store the macro which creates the ``Proof of \ldots'' text (|proofofname|
% option).
%    \begin{macrocode}
  \cslet{phfthm@prfenv@#2@val@proofofname}\cmdKV@phfmkprf@proofofname%
%    \end{macrocode}
% 
% Create the macro which will take care of pinning down the label for the
% proof-ref (see \autoref{sec:proof-ref-mechanism}). This macro first ref-steps
% the internal counter and then pins down a label, if appropriate.
%    \begin{macrocode}
  \csdef{phfthm@prfenv@#2@val@pinproofanchor}{%
    \csname phfthm@prfenv@#2@val@refstepinternalcounter\endcsname%
    \if\relax\detokenize\expandafter{\phfthm@val@proofoflabel}\relax\else%
      \edef\phfthm@tmp@larg{{proof:\phfthm@val@proofoflabel}}%
      \expandafter\label\phfthm@tmp@larg%
    \fi
  }%
  %
%    \end{macrocode}
% 
% The command to ref-step the internal proof counter.  Use the value of the
% \cmdoptionfmt{internalcounter} command option.
%    \begin{macrocode}
  \csedef{phfthm@prfenv@#2@val@refstepinternalcounter}{%
    \noexpand\refstepcounter{\cmdKV@phfmkprf@internalcounter}}%
%    \end{macrocode}
% 
% Make macros |\phfthm@prfenv@<proof-environment-name>@val@displayenvbegincmd|
% and |\phfthm@prfenv@<proof-environment-name>@val@displayenvendcmd|, which
% essentially expand to |\begin{<the-display-env>}| and |\end{<the-display-env}|
% for the display environment given in the option \cmdoptionfmt{displayenv}.
%    \begin{macrocode}
  \if\relax\detokenize\expandafter{\cmdKV@phfmkprf@displayenv}\relax%
    \csdef{phfthm@prfenv@#2@val@displayenvbegincmd}##1{}%
    \csdef{phfthm@prfenv@#2@val@displayenvendcmd}##1{}%
  \else
    \csedef{phfthm@prfenv@#2@val@displayenvbegincmd}##1{%
      \noexpand\begin{\csname phfthm@prfenv@#2@val@displayenv\endcsname}##1}%
    \csedef{phfthm@prfenv@#2@val@displayenvendcmd}##1{%
      \noexpand\end{\csname phfthm@prfenv@#2@val@displayenv\endcsname}##1}%
  \fi
%    \end{macrocode}
% 
% See if we need to call |\newenvironment| or |\renewenvironment|, depending on
% the value of the \cmdoptionfmt{override} option.
%    \begin{macrocode}
  \def\phfthm@tmp@defcmd{\newenvironment}%
  \ifKV@phfmkprf@override\def\phfthm@tmp@defcmd{\renewenvironment}\fi%
%    \end{macrocode}
% 
% Finally, (re-)define the environment.  The default value of the optional
% argument is the token |\phfthm@NOPROOFARG|, which indicates that no argument
% was provided.
% Start by calling the ``start'' hook.
%    \begin{macrocode}
  \phfthm@tmp@defcmd{#2}[1][\phfthm@NOPROOFARG]{%
    \csname phfthm@hookproof@#2@start\endcsname%
%    \end{macrocode}
% 
% First, parse the optional argument into proof label (maybe) and proof title.
% If no optional argument was given, don't give any argument to the underlying
% display environment.  If an empty argument was given, set some defaults;
% otherwise, use the necessary command to potentially parse the label and create
% the proper arguments for the underlying display environment.
%    \begin{macrocode}
    \def\phfthm@val@proofarg{##1}%
    \ifx\phfthm@val@proofarg\phfthm@test@NOPROOFARG\relax%
      \def\phfthm@val@proofoflabel{}%
      \csname phfthm@prfenv@#2@val@setdefaultprooftitle\endcsname%
      \letcs\phfthm@val@displayargs{phfthm@prfenv@#2@val@defaultproofnameargs}%
    \else%
      \if\relax\detokenize{##1}\relax%
        \def\phfthm@val@proofoflabel{}%
        \csname phfthm@prfenv@#2@val@setdefaultprooftitle\endcsname%
        \def\phfthm@val@displayargs{[{%
            \csname phfthm@prfenv@#2@val@proofofname\endcsname
            {\phfthm@val@prooftitle}%
          }]}%
      \else
        \csname phfthm@prfenv@#2@val@parselabelandmkdisplayargs\endcsname{##1}%
      \fi
    \fi%
%    \end{macrocode}
% 
% Define the |\phfthmPinProofAnchor| command (locally) in case the
% display formatting environment takes care of where to place the anchor already.
%    \begin{macrocode}
    \def\phfthmPinProofAnchor{%
      \csname phfthm@prfenv@#2@val@pinproofanchor\endcsname%
      \global\let\phfthmPinProofAnchor\relax}%
%    \end{macrocode}
%
% Start the proof's display environment, and call the corresponding hook.
%    \begin{macrocode}
    \def\x{\csname phfthm@prfenv@#2@val@displayenvbegincmd\endcsname}%
    \expandafter\x\expandafter{\phfthm@val@displayargs}%
    \csname phfthm@hookproof@#2@startafterdisplay\endcsname%
%    \end{macrocode}
% If required, pin anchor after the proof-display-environment.
% (|\phfthmPinProofAnchor| auto-destructs after first use, so it's safe to
% potentially call it a second time here). Then, call the corresponding hook.
%    \begin{macrocode}
    \phfthmPinProofAnchor%
    \expandafter\noexpand\csname phfthm@hookproof@#2@startlast\endcsname%
  }%
%    \end{macrocode}
%
% Now, the definitions for the ``end'' part of the environment.  Just call the
% relevant hooks and close the display environment.
%    \begin{macrocode}
  {%
    \expandafter\noexpand\csname phfthm@hookproof@#2@end\endcsname%
    \csname phfthm@prfenv@#2@val@displayenvendcmd\endcsname
    \expandafter\noexpand\csname phfthm@hookproof@#2@final\endcsname%
  }%
%    \end{macrocode}
% 
% Finally, define the default values of the proof-environment-specific hooks.
% These just call the corresponding global hooks (see \autoref{sec:proof-hooks}).
%    \begin{macrocode}
  \csdef{phfthm@hookproof@#2@start}{\phfthm@hookproof@startcommon{#2}}%
  \csdef{phfthm@hookproof@#2@startafterdisplay}{%
    \phfthm@hookproof@startafterdisplaycommon{#2}}%
  \csdef{phfthm@hookproof@#2@startlast}{\phfthm@hookproof@startlastcommon{#2}}%
  \csdef{phfthm@hookproof@#2@end}{\phfthm@hookproof@endcommon{#2}}%
  \csdef{phfthm@hookproof@#2@final}{\phfthm@hookproof@finalcommon{#2}}%
}
%    \end{macrocode}
% \end{macro}
% 
%
% \subsubsection{Common hooks for proofs}
%
% The hooks are documented in \autoref{sec:proof-hooks}.
%    \begin{macrocode}
\def\phfthm@hookproof@startcommon#1{}
\def\phfthm@hookproof@startafterdisplaycommon#1{}
\def\phfthm@hookproof@startlastcommon#1{}
\def\phfthm@hookproof@endcommon#1{}
\def\phfthm@hookproof@finalcommon#1{}
%    \end{macrocode}
% 
%
% \subsubsection{Default display environment for proofs}
%
% \begin{environment}{phfthm@proof@defaultdisplayenv}
%   Provide an environment which displays a proof in a similar fashion as
%   \emph{AMS}', but with some small additional features.
%    \begin{macrocode}
\newenvironment{phfthm@proof@defaultdisplayenv}[1][\proofname]{\par
  \pushQED{\qed}%
  \normalfont \topsep6\p@\@plus6\p@\relax
  \trivlist\item\relax
  \phfthmPinProofAnchor
  \phfthm@ProofTitleFmt{#1}%
  \phfthm@ProofTitleHspace
  \ignorespaces
}{%
  \popQED\endtrivlist\@endpefalse
}
%    \end{macrocode}
% \end{environment}
% 
% \begin{macro}{\phfthm@ProofTitleFmt}
% \begin{macro}{\phfthm@ProofTitleHspace}
%   These macros may be overridden to change the proof title appearance.
%    \begin{macrocode}
\def\phfthm@ProofTitleFmt#1{%
  {\itshape #1.}%
}
\def\phfthm@ProofTitleHspace{%
  \hspace{1.5ex plus 0.5ex minus 0.2ex}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Parsing the proof argument}
%
% These macros parse the argument of the proof environment to see if it is of
% the form |*<some-label>| (see \autoref{sec:proof-ref-mechanism}).
%
% \begin{macro}{\phfthm@proof@parselabel}
%   Call |\phfthm@proof@parselabel|\marg{proof environment argument} to parse
%   the argument string.  This macro will set |\phfthm@val@proofoflabel| and
%   |\phfthm@val@prooftitle| to appropriate values (respectively, the label name
%   of the corresponding theorem and a representative title such as ``Theorem
%   6'').
%    \begin{macrocode}
\def\phfthm@proof@parselabel#1{%
  \phfthm@proof@parselabel@maybelabel#1\phfthm@proof@parselabel@END%
}
\def\phfthm@proof@parselabel@maybelabel{%
  \@ifnextchar*\phfthm@proof@parselabel@label\phfthm@proof@parselabel@title%
}
\def\phfthm@proof@parselabel@label*#1\phfthm@proof@parselabel@END{%
  \edef\phfthm@val@proofoflabel{#1}%
  \def\phfthm@val@prooftitle{\phfthm@autoref{#1}}%
}
\def\phfthm@proof@parselabel@title#1\phfthm@proof@parselabel@END{%
  \def\phfthm@val@proofoflabel{}%
  \def\phfthm@val@prooftitle{#1}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\phfthm@proof@noparselabel}
%   Enjoys the same syntax as |\phfthm@proof@parselabel|, i.e., it is a drop-in
%   replacement for the latter, except that it invariably sets
%   |\phfhtm@val@proofoflabel| to an empty value and |\phfthm@val@prooftitle| to
%   the argument itself.  You could use this as a \cmdoptionfmt{parselabelcmd}
%   macro if you didn't want to parse the label.
%    \begin{macrocode}
\def\phfthm@proof@noparselabel#1{%
  \def\phfthm@val@proofoflabel{}%
  \def\phfthm@val@prooftitle{#1}%
}
%    \end{macrocode}
% \end{macro}
% 
%
% In order to look up what we are a proof of, we use |\autoref| provided by the
% \pkgname{hyperref} package.  If it is not available, fall back to the regular
% |\ref| command.
%    \begin{macrocode}
\def\phfthm@autoref{\ref}
\AtBeginDocument{%
  \@ifpackageloaded{hyperref}{\def\phfthm@autoref{\autoref}}{}
}
%    \end{macrocode}
% 
%
% \subsection{Implementation of the proof-ref machinery}
%
% ...................................
%
%    \begin{macrocode}

\providecommand\proofonname[2]{Proof on #2.}

\def\noproofref{%
  \def\phfthm@val@noproofref{1}% if this is defined, then no proof ref should be generated for the current thmlabel
}

%
% This one may also be defined to take one argument, the proof ref text.
%
\def\proofrefsize{\footnotesize}

\def\phfthm@fmt@proofref#1#2{%
  %
  % #1 = theorem's label (e.g. "prop:1")
  % #2 = full reference (e.g. "page XYZ")
  % 
  {\parfillskip=0pt\relax% Thanks http://tex.stackexchange.com/a/43239/32188 !
    \hfil\null\hfil\hbox{\proofrefsize{(\proofonname{#1}{#2})}}\par}%
}

\def\phfthm@fmt@proofref@farback#1#2{\phfthm@fmt@proofref{#1}{#2}}
\def\phfthm@fmt@proofref@farahead#1#2{\phfthm@fmt@proofref{#1}{#2}}
\def\phfthm@fmt@proofref@closeby#1#2{}

\def\phfthm@proofref@warnnolabel{%
  \PackageWarning{phfthm}{No label provided for proof reference!}%
}

\def\phfthm@proofref@impl@thmlabel{%
  \ifdefined\phfthm@val@noproofref\relax%
    % "no proof ref" was explicitly specified
  \else%
    % make sure \phfthm@val@thmlabel is defined, maybe empty
    \providecommand\phfthm@val@thmlabel{}%
    % generate the proof reference for current thmlabel
    \edef\phfthm@tmpa{{\phfthm@val@thmlabel}}%
    \expandafter\notblank\phfthm@tmpa{%
      \expandafter\phfthm@proofref@impl\phfthm@tmpa%
    }{%
      \phfthm@proofref@warnnolabel% no label provided
    }%
  \fi%
}

%
% allow the proof to be this many pages away. Use -1 to force display of reference.
%
\newcommand\phfthmProofrefPageBackTolerance{1}
\newcommand\phfthmProofrefPageAheadTolerance{1}

\newcounter{phfthmInternalProofrefCounter}

\def\phfthm@proofref@impl#1{%
  %
  % #1 = referenced label
  %
  % Check to see if the proof is far away (further than on the next page).  Only if that's
  % the case, display the reference.
  %
  % See http://tex.stackexchange.com/a/2526 to test whether ref is on same page. Note that
  % was problematic, probably due to hyperref. I needed to use my own \phfthm@min@pageref
  % without any hyper linking mechanism in place.
  %
  \refstepcounter{phfthmInternalProofrefCounter}\label{internalproofref\thephfthmInternalProofrefCounter}%
  \edef\phfthm@proofref@tmp@proofpage{\phfthm@min@pageref{proof:#1}}%
  \edef\phfthm@proofref@tmp@thispage{\phfthm@min@pageref{internalproofref\thephfthmInternalProofrefCounter}}%
  \edef\phfthm@proofref@tmp@pagediff{\the\numexpr\phfthm@proofref@tmp@proofpage-\phfthm@proofref@tmp@thispage\relax}%
  \ifnum\numexpr\phfthm@proofref@tmp@pagediff\relax<\numexpr-\phfthmProofrefPageBackTolerance\relax%
    % far back
    \phfthm@fmt@proofref@farback{#1}{\autopageref{proof:#1}}%
  \else%
    \ifnum\numexpr\phfthm@proofref@tmp@pagediff\relax>\numexpr\phfthmProofrefPageAheadTolerance\relax%
      % far ahead
      \phfthm@fmt@proofref@farahead{#1}{\autopageref{proof:#1}}%
    \else%
      % close
      \phfthm@fmt@proofref@closeby{#1}{\autopageref{proof:#1}}%
    \fi%
  \fi%
%  [\number\numexpr\phfthm@proofref@tmp@proofpage\relax{} vs % DEBUG
%  \number\numexpr\phfthm@proofref@tmp@thispage\relax or % DEBUG
%  \number\numexpr1+\phfthm@proofref@tmp@thispage\relax] % DEBUG
}

\def\phfthm@autorefnameof#1{%
  % 
  % Extract the counter part of the reference `section.NN', which is 4th element in the
  % \r@label macro
  %
  % Code extracted from hyperref.sty
  % 
  \expandafter\ifx\csname r@#1\endcsname\relax%
    \textbf{??}%
  \else%
    \expandafter\expandafter\expandafter\phfthm@HyPsd@autorefname%
        \csname r@#1\endcsname{}{}{}{}\@nil%
  \fi%
}
\def\phfthm@HyPsd@autorefname#1#2#3#4#5\@nil{%
  \ifx\\#4\\%
  \else%
    \phfthm@HyPsd@@autorefname#4.\@nil%
  \fi%
}
\def\phfthm@HyPsd@@autorefname#1.#2\@nil{%
  \ltx@IfUndefined{#1autorefname}{%
    \ltx@IfUndefined{#1name}{%
    }{%
      \csname#1name\endcsname%
    }%
  }{%
    \csname#1autorefname\endcsname%
  }%
}

\def\phfthm@min@pageref#1{%
  \ifcsname r@#1\endcsname%
    %
    % Dark magic going on here. Copied from hyperref.sty, in "\def\HyPsd@@@pageref..."
    % 
    \expandafter\expandafter\expandafter\expandafter
    \expandafter\expandafter\expandafter\@car
    \expandafter\expandafter\expandafter\@gobble
    \csname r@#1\endcsname{}\@nil
  \else%
    0%
  \fi%
}




% ==============================================================================
%                    THEOREM HEADING MACHINERY
% ==============================================================================


\define@cmdkey{phfthmmkthmheading}{thmstyle}{}
\define@cmdkey{phfthmmkthmheading}{internalcounter}{}


\newcounter{phfthmheadingcounter}%

% 
% Creates a new environment \begin{thmheading}{Title} .... \end{thmheading} for
% customizing the heading on-the-fly. Useful for my formatting of definitions.
% 
% You can also use \label{...} and \ref{} which yields the title.
% 
\newcommand\phfthmMakeThmheadingEnvironment[2][]{%
  % 
  % #1 = options (thmstyle=xyz)
  % 
  % #2 = environment name
  %
  %
  % First, parse options:
  % 
  %   set defaults:
  %
  \def\cmdKV@phfthmmkthmheading@thmstyle{plain}%
  \def\cmdKV@phfthmmkthmheading@internalcounter{phfthmheadingcounter}%
  %
  %   manually given options:
  % 
  \setkeys{phfthmmkthmheading}{#1}%
  % 
  %
  % And the definitions, per se:
  %
  \csdef{phfthm@thmheading@#2@val@title}{$\langle$No Title Given$\rangle$}%
  \theoremstyle{\cmdKV@phfthmmkthmheading@thmstyle}%
  % 
  \newtheorem*{phfthm@internal@thmheading@#2}{\csname phfthm@thmheading@#2@val@title\endcsname}%
  %
  % define the relevant environment
  % 
  \newenvironment{#2}[1]{%
    \csdef{phfthm@thmheading@#2@val@title}{##1}%
    \letcs\thephfthmheadingcounter{phfthm@thmheading@#2@val@title}%
    \csname phfthm@internal@thmheading@#2\endcsname%
    % \hspace: see http://tex.stackexchange.com/a/88493/32188, especially the first comment
    \hspace*{0pt}\refstepcounter{\cmdKV@phfthmmkthmheading@internalcounter}%
    \csname phfthm@hook@thmheading@#2@start\endcsname{##1}%
    % add some flexibility in the hspace
    \hskip 0em plus 0.5em minus 0em%
    \ignorespaces%
  }{%
    \csname phfthm@hook@thmheading@#2@end\endcsname%
    \csname endphfthm@internal@thmheading@#2\endcsname%
  }%
  % 
  \csdef{phfthm@hook@thmheading@#2@start}##1{\phfthm@hook@thmheading@start{##1}}%
  \csdef{phfthm@hook@thmheading@#2@end}{\phfthm@hook@thmheading@end}%
  %
}

\def\phfthm@hook@thmheading@start#1{}
\def\phfthm@hook@thmheading@end{}






% ==============================================================================
%                    STYLES AND THEOREM SETS
% ==============================================================================


%
% Define theorem sets
%
\def\phfthm@def@thmset@optlist{}
\def\phfthm@def@thmset#1{\appto\phfthm@def@thmset@optlist{#1,}\csdef{phfthm@thmset@#1}}


% Note: should be defined by the package option processing mechanism: \phfthm@val@mkthmoptarg@{theorem|defn}
\def\phfthm@def@thmset@mktheorem{\expandafter\phfMakeTheorem\phfthm@val@mkthmoptarg@theorem}
\def\phfthm@def@thmset@mkdefn{\expandafter\phfMakeTheorem\phfthm@val@mkthmoptarg@defn}

\def\phfthm@thmset@{% empty set, name ''
}

\phfthm@def@thmset{empty}{
  % empty set, name 'empty'
}
\phfthm@def@thmset{simple}{
  \phfthm@def@thmset@mktheorem{theorem}{Theorem}
  \phfthm@def@thmset@mktheorem{proposition}{Proposition}
  \phfthm@def@thmset@mktheorem{lemma}{Lemma}
  \phfthm@def@thmset@mktheorem{corollary}{Corollary}
}
\phfthm@def@thmset{default}{
  \phfthm@def@thmset@mktheorem{theorem}{Theorem}
  \phfthm@def@thmset@mktheorem{proposition}{Proposition}
  \phfthm@def@thmset@mktheorem{lemma}{Lemma}
  \phfthm@def@thmset@mktheorem{corollary}{Corollary}
  \phfthm@def@thmset@mktheorem{conjecture}{Conjecture}
  \phfthm@def@thmset@mktheorem{remark}{Remark}
  \phfthm@def@thmset@mkdefn{definition}{Definition}
}
\phfthm@def@thmset{shortnames}{
  \phfthm@def@thmset@mktheorem{thm}{Theorem}
  \phfthm@def@thmset@mktheorem{prop}{Proposition}
  \phfthm@def@thmset@mktheorem{lem}{Lemma}
  \phfthm@def@thmset@mktheorem{cor}{Corollary}
  \phfthm@def@thmset@mktheorem{conj}{Conjecture}
  \phfthm@def@thmset@mktheorem{rem}{Remark}
  \phfthm@def@thmset@mkdefn{defn}{Definition}
}
\phfthm@def@thmset{rich}{

  \phfthm@thmset@default % the default set, plus:

  \phfthm@def@thmset@mktheorem{idea}{Idea}
  \phfthm@def@thmset@mktheorem{question}{Question}
  \phfthm@def@thmset@mktheorem{problem}{Problem}
}

\newcommand\phfthmLoadThmSet[3]{%
  % 
  % #1 = options for theorem definitions
  % #2 = options for definition definitions
  % #3 = name of the thm set to load
  %
  \ifcsname phfthm@thmset@#3\endcsname%
    \edef\phfthm@val@mkthmoptarg@theorem{#1}%
    \edef\phfthm@val@mkthmoptarg@defn{#2}%
    \csname phfthm@thmset@#3\endcsname%
  \else%
    \PackageWarning{phfthm}{Unknown theorem set: `#3'!}%
  \fi%
}


% ==============================================================================

%
% The machinery is in place, now define and parse the package options.
%

\define@boolkey{phfthmpkg}{smallproofs}[true]{}
\KV@phfthmpkg@smallproofstrue% true by default

\define@boolkey{phfthmpkg}{qedsymbolblacksquare}[true]{}
\KV@phfthmpkg@qedsymbolblacksquaretrue% true by default


\define@boolkey{phfthmpkg}{proofenv}[true]{}
\KV@phfthmpkg@proofenvtrue% true by default

\define@boolkey{phfthmpkg}{prooftitleitbf}[true]{}
\KV@phfthmpkg@prooftitleitbffalse% false by default

\define@boolkey{phfthmpkg}{sepcounters}[true]{}
\KV@phfthmpkg@sepcountersfalse% false by default

\define@boolkey{phfthmpkg}{thmheading}[true]{}
\KV@phfthmpkg@thmheadingtrue% set to true by default because these are only stand-alone definitions
\define@cmdkey{phfthmpkg}{thmheadingstyle}{}
\def\cmdKV@phfthmpkg@thmheadingstyle{plain}

%
% proof ref options
%
\newif\ifKV@phfthmpkg@proofref
\KV@phfthmpkg@proofreffalse% false by default
\def\cmdKV@phfthmpkg@proofref@style{}
\define@key{phfthmpkg}{proofref}[]{%
  \ifblank{#1}{%
    % blank argument provided, set some sensible defaults with proofref on:
    \KV@phfthmpkg@proofreftrue%
    \def\cmdKV@phfthmpkg@proofref@style{default}%
    %
  }{%
    \ifstrequal{#1}{false}{%
      \KV@phfthmpkg@proofreffalse%
    }{%
      \KV@phfthmpkg@proofreftrue%
      %
      % and set value:
      \def\cmdKV@phfthmpkg@proofref@style{#1}%
    }%
  }%
}


\define@key{phfthmpkg}{resetstyle}[]{%
  \KV@phfthmpkg@smallproofsfalse%
  \KV@phfthmpkg@qedsymbolblacksquarefalse%
  \KV@phfthmpkg@prooftitleitbffalse%
  \KV@phfthmpkg@sepcountersfalse%
  \KV@phfthmpkg@proofreffalse%
  % 
  \if\relax\detokenize{#1}\relax% expect empty arg.
  \else%
    \PackageWarning{phfthm}{'resetstyle' does not take any argument.}%
  \fi%
}



% \define@choicekey{phfthmpkg}{thmset}[\val]{\phfthm@def@thmset@optlist}{ ... but with expanded option list arg
\def\@tmpa{\define@choicekey{phfthmpkg}{thmset}[\val]}
\edef\@tmpb{{\phfthm@def@thmset@optlist}}
\expandafter\@tmpa\@tmpb{%
  \xdef\cmdKV@phfthmpkg@thmset{\val}%
}
\def\cmdKV@phfthmpkg@thmset{default}% by default, load the default set


%
% These set which theorem style to use for theorems and definitions, when loading the
% given thmset.
%
\define@cmdkey{phfthmpkg}{theoremstyle}{}
\def\cmdKV@phfthmpkg@theoremstyle{plain}
%
\define@cmdkey{phfthmpkg}{definitionstyle}{}
\def\cmdKV@phfthmpkg@definitionstyle{definition}


\DeclareOptionX*{%
  \PackageWarning{phfthm}{Invalid option: `\CurrentOption'}%
}
\ProcessOptionsX<phfthmpkg>


% ==============================================================================



%
% Now, execute options-controlled actions, such as defining theorem sets.
%


\def\phfthm@pkgopterr@require@proofenv#1{%
  \ifKV@phfthmpkg@proofenv\else%
    \PackageError{phfthm}{Option `#1' depends on `proofenv=true'}%
  \fi
} 


\ifKV@phfthmpkg@smallproofs
  \apptocmd\phfthm@hookproof@startcommon{\def\baselinestretch{1.2}\footnotesize}{}{%
    Failed to change command \string\phfthm@hook@start@proof}
\fi

\ifKV@phfthmpkg@qedsymbolblacksquare
  \RequirePackage{amssymb}
  \providecommand\filledsquare{\ensuremath{\blacksquare}}
  \renewcommand\qedsymbol{\text{\tiny\ensuremath{\filledsquare}}}
\fi

\ifKV@phfthmpkg@prooftitleitbf
  \def\phfthm@ProofTitleFmt#1{{\itshape\bfseries#1.}}
\fi

\ifKV@phfthmpkg@sepcounters
  \def\phfthm@val@mkthmopt@counteropts{}
\fi

\ifKV@phfthmpkg@proofref

  \def\phfthm@proofref@style@margin{%
    % 
    \def\phfthm@fmt@proofref##1##2{%
      % 
      % ##1 = full reference (e.g. "page XYZ")
      % 
      \marginpar{\proofrefsize{\proofonname{##1}{##2}}}%
    }%
  }
  \def\phfthm@proofref@style@default{}
  \def\phfthm@proofref@style@{}
  % 
  \def\phfthm@proofref@style@always{
    \def\phfthmProofrefPageBackTolerance{-1}
    \def\phfthmProofrefPageAheadTolerance{-1}
  }
  \def\phfthm@proofref@style@onlyifveryfar{
    \def\phfthmProofrefPageBackTolerance{2}
    \def\phfthmProofrefPageAheadTolerance{4}
  }
  % 
  \def\phfthm@proofref@style@longref{
    \def\proofonname##1##2{The proof of this \phfthm@autorefnameof{##1} can be found on ##2.}
    \def\phfthm@fmt@proofref##1##2{%
      % 
      % #1 = theorem's label (e.g. "prop:1")
      % #2 = full reference (e.g. "page XYZ")
      % 
      \par{\raggedleft\proofrefsize{(\proofonname{##1}{##2})}\par}%
    }
  }

  \def\phfthm@exec@proofrefstyles#1\phfthm@END{%
    \phfthm@internal@execattribs{phfthm@proofref@style@}{ProofRef Style}{#1}}
  \expandafter\phfthm@exec@proofrefstyles\cmdKV@phfthmpkg@proofref@style\phfthm@END


  \let\phfthm@def@thmset@mktheorem@OLD\phfthm@def@thmset@mktheorem%
  \def\phfthm@def@thmset@mktheorem#1#2{% #1 = prop env name ("proposition"), #2 = prop title name ("Proposition")
    \phfthm@def@thmset@mktheorem@OLD{#1}{#2}%
    \expandafter\apptocmd\csname phfthm@hook@end@#1\endcsname{%
      \phfthm@proofref@impl@thmlabel%
    }{}{Failed to append to command `\expandafter\string\csname phfthm@hook@end@#1\endcsname!!}%
  }

\fi



%
% Common counter, in case we use a common counter for all thm types
%

\newcounter{phfthmcounter}
\setcounter{phfthmcounter}{0}

\ifdefined\phfthm@val@mkthmopt@counteropts% already defined by some above option, e.g. separate counters
\else

  % 
  % provide common counter
  %
  \def\phfthm@val@mkthmopt@counteropts{counter=phfthmcounter}

\fi


%
% load the theorem set defined by the options
%

\phfthmLoadThmSet%
{[\phfthm@val@mkthmopt@counteropts,thmstyle=\cmdKV@phfthmpkg@theoremstyle]}% opts for theorems
{[\phfthm@val@mkthmopt@counteropts,thmstyle=\cmdKV@phfthmpkg@definitionstyle]}% opts for definitions
{\cmdKV@phfthmpkg@thmset} % the theorem set


%
% Styling the proofs
%


%
% override it by our own:
%

\ifKV@phfthmpkg@proofenv

  \phfMakeProofEnv[override=true]{proof}

\fi

%\let\proof\phfthm@proof
%\let\endproof\endphfthm@proof



\ifKV@phfthmpkg@thmheading % also set \cmdKV@phfthmpkg@thmheadingstyle

  \phfthmMakeThmheadingEnvironment[thmstyle=\cmdKV@phfthmpkg@thmheadingstyle]{thmheading}

\fi



%    \end{macrocode}
%
%\Finale
\endinput
