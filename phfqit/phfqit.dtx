% \iffalse meta-comment
%
% Copyright (C) 2016 by Philippe Faist <phfaist@gmail.com>
% -------------------------------------------------------
% 
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in:
%
%    http://www.latex-project.org/lppl.txt
%
% and version 1.3 or later is part of all distributions of LaTeX 
% version 2005/12/01 or later.
%
% \fi
%
% \iffalse
%<*driver>
\ProvidesFile{phfqit.dtx}
%</driver>
%<package>\NeedsTeXFormat{LaTeX2e}[2005/12/01]
%<package>\ProvidesPackage{phfqit}
%<*package>
    [2016/08/15 v1.0 phfqit package]
%</package>
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{xcolor}
\makeatletter
\providecommand\phfnote@pkgdoc@setupmainfont{
  \renewcommand{\rmdefault}{futs}% only rm font, not math
}\makeatother
\usepackage[preset=xpkgdoc]{phfnote}
\usepackage{phfqit}
\usepackage{needspace}
\EnableCrossrefs         
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{phfqit.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
%
% \changes{v1.0}{2016/04/20}{Initial version}
%
% \GetFileInfo{phfqit.dtx}
%
% \DoNotIndex{\newcommand,\newenvironment,\def,\gdef,\edef,\xdef,\if,\else,\fi,\ifx}
% 
% \title{\phfqitltxPkgTitle{phfqit}}
% \author{Philippe Faist\quad\email{phfaist@gmail.com}}
% \date{\pkgfmtdate\filedate}
% \maketitle
%
% \begin{abstract}
%   \pkgname{phfqit}---Utilities to typeset stuff in Quantum Information Theory
%   (quite biased towards theory), in particular general mathematical symbols,
%   operators, and shorthands for entropy measures.
% \end{abstract}
%
% \inlinetoc
%
% \section{Introduction}
%
% This package provides some useful definitions, mainly for notation of
% mathematical expressions which are used in quantum information theory (at
% least by me).
%
% Are included utilities for:
% \begin{itemize}
% \item General symbols and mathematical expressions (identity operator,
%   trace, rank, diagonal, \ldots)  (\autoref{sec:symbols})
% \item Formatting of bits and bit strings (\autoref{sec:bits})
% \item Formatting of names of logical gates (\autoref{sec:gates})
% \item Typesetting the names of Lie groups and algebras, for example $\su(N)$
%   (\autoref{sec:Lie-groups-algebras})
% \item Bra-ket notation, and delimited expressions such as average, norm,
%   \ldots (\autoref{sec:delimited})
% \item Typesetting entropy measures, including the Shannon/von Neumann entropy,
%   the smooth entropies, relative entropies, as well as my coherent relative
%   entropy
% \end{itemize}
%
%
% \section{Basic Usage}
%
% This package is straightforward to use.  There are no package options.
% \begin{verbatim}
% \usepackage{phfqit}
% \end{verbatim}
%
% [TODO: In the future, use package options to control which definitions we
% want?]
%
% \subsection{Semantic vs. Syntactic Notation}
%
% The macros in this package are meant to represent a \emph{mathematical
% quantity}, independently of its final \emph{notation}.  For example, |\Hmaxf|
% indicates corresponds to the ``new-style'' max-entropy defined with the
% fidelity,\footnote{see Marco Tomamichel, Ph. D., ETH Zurich (2012)
% \href{https://arxiv.org/abs/1203.2142}{arXiv:1203.2142}} independently of the
% notation.  Then, if the default notation ``$\Hmaxf{}$'' doesn't suit your
% taste, you may then simply redefine this command to display whatever you like
% (see for example instructions in \autoref{sec:entropy-measures}).  This allows
% to keep better distinction between different measures which may share the same
% notation in different works of literature.  It also allows to switch notation
% easily, even in documents which use several quantities whose notation may be
% potentially conflicting.
%
%
% \subsection{Size Specification}
% \label{topic:size-specification-backtick}
%
% Many of the macros in this package allow their delimiters to be sized
% according to your taste.  For example, if there is a large symbol in an
% entropy measure, say
% \begin{align}
%  \Hmin{\displaystyle\bigotimes_i A_i}[B]\ ,
% \end{align}
% then it may be necessary to tune the size of the parenthesis delimiters.
%
% This is done with the optional size specification \meta{size-spec}.  The
% \meta{size-spec}, whenever it is accepted, is always optional.
%
% The \meta{size-spec} starts with the backtick character ``|`|'', and is
% followed by a single token which may be a star |*| or a size modifier macro
% such as |\big|, |\Big|, |\bigg| and |\Bigg|.  If the star is specified, then
% the delimiters are sized with |\left| and |\right|; otherwise the
% corresponding size modifier is used.  When no size specification is present,
% then the normal character size is used.
%
% For example:
% \begin{center}
%   \begin{tabular}{ll}
%       |\Hmin{\bigotimes_i A_i}[B]|  & gives\quad  $\Hmin{\displaystyle\bigotimes_i A_i}[B]$, \\[1.5em]
%       |\Hmin`\Big{\bigotimes_i A_i}[B]|  & gives\quad  $\Hmin`\Big{\displaystyle\bigotimes_i A_i}[B]$,~~and \\[1.5em]
%       |\Hmin`*{\bigotimes_i A_i}[B]|  & gives\quad  $\Hmin`*{\displaystyle\bigotimes_i A_i}[B]$. \\
%   \end{tabular}
% \end{center}
%
%
% \section{General Symbols (and Math Operators)}
% \label{sec:symbols}
%
% \DescribeMacro{\Hs}
% Hilbert space = $\Hs$.
%
% \DescribeMacro{\Ident}
% Identity operator = $\Ident$.
%
% \DescribeMacro{\IdentProc}
% Identity process.  Possible usage syntax is:
% \begin{center}
% \begin{tabular}{lc}
%     |\IdentProc[A][A']{\rho}| &  $\IdentProc[A][A']{\rho}$ \\
%     |\IdentProc[A]{\rho}| &  $\IdentProc[A]{\rho}$ \\
%     |\IdentProc[A][A']{}| &  $\IdentProc[A][A']{}$ \\
%     |\IdentProc[A]{}| &  $\IdentProc[A]{}$ \\
%     |\IdentProc{}| &  $\IdentProc{}$ \\
%     |\IdentProc{\rho}| &  $\IdentProc{\rho}$ \\
%     |\IdentProc`\big[A]{\rho}| &  $\IdentProc`\big[A]{\rho}$ \\
% \end{tabular}
% \end{center}
% This macro accepts a size specification with the backtick (`|`|'), see
% \autoref{topic:size-specification-backtick}.
%
% \begingroup\catcode`\^=12\relax
% \DescribeMacro{\ee^X}\endgroup
% A macro for the exponential.  Type the \LaTeX{} code as if |\ee| were just the symbol,
% i.e.\@ as |\ee^{<ARGUMENT>}|.  The ideas is that this macro may be redefined to change
% the appearance of the $e$ symbol, or even to change the notation to |\exp{<ARGUMENT>}|
% if needed for inline math.
%
%
% \subsection{Math/Linear Algebra Operators}
% \label{sec:math-operators}
%
% \needspace{6\baselineskip}
% \DescribeMacro{\tr} \DescribeMacro{\supp} \DescribeMacro{\rank}
% \DescribeMacro{\linspan} \DescribeMacro{\spec} \DescribeMacro{\diag} Provide
% some common math operators.  The trace $\tr$, the support $\supp$, the rank
% $\rank$, the linear span $\linspan$, the spectrum $\spec$ and the diagonal
% matrix $\diag$.  (Note that |\span| is already defined by \LaTeX{}, so that we
% resort to |\linspan|.)  \vspace{1.5cm}
%
% \DescribeMacro{\Re} \DescribeMacro{\Im} Also, redefine |\Re| and |\Im| (real
% and imaginary parts of a complex number), to the more readable $\Re(z)$ and
% $\Im(z)$.  (The original symbols were {\makeatletter $\phfqit@Re(z)$ and
% $\phfqit@Im(z)$}.)
%
% \subsection{Poly symbol}
%
% \DescribeMacro{\poly} Can be typeset in $\poly(n)$ time.
% \iffalse meta-comment \changedreftext{v1.0-added-poly-command} \fi
% 
%
% \subsection{Bits and Bit Strings}
% \label{sec:bits}
%
% \DescribeMacro{\bit} Format a bit value, for example |\bit{0}| or |\bit0|
% gives $\bit0$ or $\bit1$.  This command works both in math mode and text mode.
%
% \DescribeMacro{\bitstring} Format a bit string.  For example
% |\bitstring{01100101}| is rendered as \bitstring{01100101}.  This command
% works both in math mode and text mode.
%
% \subsection{Logical Gates}
% \label{sec:gates}
%
% \DescribeMacro{\gate} Format a logical gate.  Essentially, this command
% typesets its argument in small-caps font.  For example, with |\gate{C-not}|
% you get \gate{C-not}.  (The default formatting ignores the given
% capitalization, but if you redefine this command you could exploit this,
% e.g.\@ by making the ``C'' in ``Cnot'' larger than the ``not''.)
%
% This command works both in math mode and in text mode.
%
% \needspace{5\baselineskip}
% \DescribeMacro{\AND} \DescribeMacro{\XOR} \DescribeMacro{\CNOT}
% \DescribeMacro{\NOT} \DescribeMacro{\NOOP} Some standard gates.  These typeset
% respectively as \AND, \XOR, \CNOT, \NOT, and \NOOP. \vspace{3\baselineskip}
%
%
% \section{Lie Groups and Algebras}
% \label{sec:Lie-groups-algebras}
%
% \needspace{7\baselineskip}
% \DescribeMacro{\uu(N)} \DescribeMacro{\UU(N)} \DescribeMacro{\su(N)}
% \DescribeMacro{\SU(N)} \DescribeMacro{\so(N)} \DescribeMacro{\SO(N)}
% \DescribeMacro{\SN(N)} Format some common Lie groups and algebras.
%
% |\SN(N)| is the symmetric group of $N$ items, and formats by default as
% $\SN(N)$. \vspace{4\baselineskip}
%   
% \section{Bra-Ket Notation and Delimited Expressions}
% \label{sec:bra-ket} \label{sec:delimited}
%
% All commands here work in math mode only.  They all accept an optional
% argument, which is a size modifier.  Use the starred form to enclose the
% delimiters with |\left...\right| and have the size determined automatically.
% Usage for example is:
% \begin{center}
%   \begin{tabular}{lc}
%       |\ket{\psi}|  &  $\ket{\psi}$ \\[1em]
%       |\ket[\big]{\psi}|  &  $\ket[\big]{\psi}$ \\[1em]
%       |\ket[\Big]{\psi}|  &  $\ket[\Big]{\psi}$ \\[1em]
%       |\ket[\bigg]{\psi}|  &  $\ket[\bigg]{\psi}$ \\[1em]
%       |\ket[\Bigg]{\psi}|  &  $\ket[\Bigg]{\psi}$ \\[1em]
%       |\ket*{\displaystyle\sum_k \psi_k}|  &  $\ket*{\displaystyle\sum_k \psi_k}$ \\
%   \end{tabular}
% \end{center}
%
% \DescribeMacro{\ket}
% Typeset a quantum mechanical ket.  |\ket{\psi}| gives $\ket{\psi}$.
%
% \DescribeMacro{\bra}
% Typeset a bra.  |\bra{\psi}| gives $\bra{\psi}$.
%
% \DescribeMacro{\braket}
% Typeset a bra-ket inner product.  |\braket{\phi}{\psi}| gives $\braket{\phi}{\psi}$.
%
% \DescribeMacro{\ketbra}
% Typeset a ket-bra outer product.  |\ketbra{\phi}{\psi}| gives $\ketbra{\phi}{\psi}$.
%
% \DescribeMacro{\proj}
% Typeset a rank-1 projector determined by a ket.  |\proj{\psi}| gives $\proj{\psi}$.
%
% \DescribeMacro{\matrixel} Typeset a matrix element.
% |\matrixel{\phi}{A}{\psi}| gives $\matrixel{\phi}{A}{\psi}$.
%
% \DescribeMacro{\dmatrixel} Typeset a diagonal matrix element of an operator.
% |\dmatrixel{\phi}{A}| gives $\dmatrixel{\phi}{A}$.
%
% \DescribeMacro{\innerprod} Typeset an inner product using the mathematicians' notation.
% |\innerprod{\phi}{\psi}| gives $\innerprod{\phi}{\psi}$.
%
%
% There are also some further delimited expressions defined, for convenience.
%
% \DescribeMacro{\abs} The absolute value of an expression.  |\abs{A}| gives
% $\abs{A}$.
%
% \DescribeMacro{\avg} The average of an expression. |\avg[\big]{\sum_k A_k}|
% gives $\avg[\big]{\sum_k A_k}$.
%
% \DescribeMacro{\norm} The norm of an expression.  |\norm{A_k}| gives
% $\norm{A_k}$.  (You can add subscripts, e.g.\@ |\norm{A_k}_\infty| is
% $\norm{A_k}_\infty$.)
%
% \DescribeMacro{\intervalc} A closed interval. |\intervalc{x}{y}| gives
% $\intervalc{x}{y}$.
%
% \DescribeMacro{\intervalo} An open interval. |\intervalo{x}{y}| gives
% $\intervalo{x}{y}$.
%
% \DescribeMacro{\intervalco} A semi-open interval, closed on the lower bound
% and open on the upper bound. |\intervalco{x}{y}| gives $\intervalco{x}{y}$.
%
% \DescribeMacro{\intervaloc} A semi-open interval, open on the lower bound
% and closed on the upper bound. |\intervaloc{x}{y}| gives $\intervaloc{x}{y}$.
%
%
%
% \section{Entropy Measures}
%
% DOC TODO: THIS DOC WILL BE OUTDATED AFTER MY CHANGES ........... !!!!!!!
% ..................
%
% \subsection{Entropy, Conditional Entropy}
% \label{sec:entropy-measures}
%
% The entropy measures (except for |\Hfunc|) all share the same syntax.  This
% syntax is only described for the min-entropy |\Hmin|, but the other entropy
% measures enjoy the same features.
%
% The name of the macros are chosen such that they identify the \emph{abstract
% entropy measure}, and not necessarily the way one uses to write it down in a
% specific context.  For example, for the ``old'' max-entropy
% $H_\mathrm{max,old}(X)_\rho = \log\rank\rho$, you should use |\Hzero|
% independently of whether it should be denoted by $H_0$, $H_\mathrm{max}$ or
% $H_\mathrm{max,old}$.  This allows you to change the notation by redefining
% the command |\Hzero|, while making sure that the correct quantity is
% addressed.  (You might have both ``old''-style and ``new''-style max-entropy
% in the same paper.)  The macros |\Hmin|, |\Hzero|, |\Hmaxf| and |\HH| may be
% redefined to change the subscript by using the following code (change
% ``|\mathrm{max},0|'' to your favorite subscript text):
% \begin{verbatim}
% \makeatletter
% \renewcommand\Hzero{\@HHbase{\HHSym}{\mathrm{max},0}}
% \makeatother
% \end{verbatim}
%
% These commands are robust, meaning they can be used for example in figure
% captions and section headings.
%
% \DescribeMacro{\Hmin} Min-entropy.  The general syntax is
% |\Hmin|\hspace{0pt}\oarg{state}\hspace{0pt}\oarg{epsilon}\hspace{0pt}\relax
% \marg{target system}\hspace{0pt}\oarg{conditioning system}.  For example:
% \begin{center}
%   \begin{tabular}{lc}
%       |\Hmin{X}|   & $\Hmin{X}$ \\
%       |\Hmin[\rho]{X}|   & $\Hmin[\rho]{X}$ \\
%       |\Hmin[\rho][\epsilon]{X}[Y]|   & $\Hmin[\rho][\epsilon]{X}[Y]$ \\
%       \verb+\Hmin[\rho|\rho][\epsilon]{X}[Y]+   & $\Hmin[\rho\mid\rho][\epsilon]{X}[Y]$ \\
%       |\Hmin[][\epsilon]{X}[Y]|   & $\Hmin[][\epsilon]{X}[Y]$ \\
%   \end{tabular}
% \end{center}
%
% \DescribeMacro{\HH} Shannon/von Neumann entropy.  This macro has the same
% arguments as for |\Hmin| (even though, of course, there is no real use in
% smoothing the Shannon/von Neumann entropy\ldots).  For example,
% |\HH[\rho]{X}[Y]| gives $\HH[\rho]{X}[Y]$.
%
% \DescribeMacro{\Hzero} R\'enyi-zero max-entropy.  This macro has the same
% arguments as for |\Hmin|.  For example, |\Hzero[][\epsilon]{X}[Y]| gives
% $\Hzero[][\epsilon]{X}[Y]$.
%
% \DescribeMacro{\Hmaxf} The max-entropy.  This macro has the same
% arguments as for |\Hmin|.  For example, |\Hmaxf[][\epsilon]{X}[Y]| gives
% $\Hmaxf[][\epsilon]{X}[Y]$.
%
% \DescribeMacro{\Hfunc} The entropy, written as a mathematical function.  It is
% useful to write, e.g., $\Hfunc(p_1\rho_1 + p_2\rho_2)$ (code:
% |\Hfunc(p_1\rho_1 + p_2\rho_2)|).  Sizing specifications also work, e.g.\@
% |\Hfunc`\big(x)| or |\Hfunc`*(x)|.  However there is neither support for an
% epsilon-like superscript nor for a conditioning system.
%
% \DescribeMacro{\HHSym} You may redefine this macro if you want to change the
% ``$H$'' symbol of all entropy measures.
% \begingroup \def\HHSym{\spadesuit} For example, with
% |\renewcommand\HHSym{\spadesuit}|, |\Hmin{A}[B]| would give $\Hmin{A}[B]$.
% \endgroup
%
% \subsection{Relative Entropy Measures}
% \label{sec:relative-entropies}
%
% Relative entropies also have a corresponding set of commands.
%
% \DescribeMacro{\DD}
% Generic relative entropy.  The syntax of this command is either of the following:\\
% |\DD|\hspace{0pt}\meta{size-spec}\hspace{0pt}\marg{state}\hspace{0pt}\marg{relative-to state},\\
% |\DD_|\marg{subscript}\hspace{0pt}\meta{size-spec}\hspace{0pt}\marg{state}\hspace{0pt}\marg{relative-to state},\\
% |\DD_|\marg{subscript}|^|\marg{superscript}\hspace{0pt}\meta{size-spec}\relax
% \hspace{0pt}\marg{state}\hspace{0pt}\marg{relative-to state},\\
% |\DD^|\marg{superscript}\hspace{0pt}\meta{size-spec}\hspace{0pt}\marg{state}\hspace{0pt}\marg{relative-to state}.
%
% In all cases, the argument is typeset as:
% $\bigl(\meta{state}\big\Vert\meta{relative-to state}\bigr)$.  The size of the
% delimiters can be set with a size specification using the standard backtick
% syntax, as for the other entropies and as described in
% \autoref{topic:size-specification-backtick}.
% 
% Examples:
% \begin{center}
%   \begin{tabular}{lc}
%       |\DD{\rho}{\sigma}|  & $\DD{\rho}{\sigma}$ \\
%       |\DD*{\rho}{\sigma}|  & $\DD*{\rho}{\sigma}$ \\
%       |\DD`\big{\rho}{\sigma}|  & $\DD`\big{\rho}{\sigma}$ \\
%   \end{tabular}
% \end{center}
%
% You can also play around with subscripts and superscripts, but it is
% recommended to use the macros |\Dminf|, |\Dminz| and |\Dmax| directly.
% Specifying the subscripts and superscripts to |\DD| should only be done within
% new custom macros to define new relative entropy measures.
% \begin{center}
%   \begin{tabular}{lc}
%       |\DD_{\mathrm{Rob}}^{\epsilon}{\rho}{\sigma}|  & $\DD_{\mathrm{Rob}}^{\epsilon}{\rho}{\sigma}$ \\
%       |\DD^{sup}{\rho}{\sigma}|  & $\DD^{sup}{\rho}{\sigma}$ \\
%   \end{tabular}
% \end{center}
%
% \DescribeMacro{\Dmax} The max-relative entropy.  The syntax is
% |\Dmax|\hspace{0pt}\oarg{epsilon}\hspace{0pt}\meta{size-spec}\relax
% \hspace{0pt}\marg{state}\hspace{0pt}\marg{relative-to state}
%
% For example |\Dmax[\epsilon]{\rho}{\sigma}| gives
% $\Dmax[\epsilon]{\rho}{\sigma}$ and |\Dmax[\epsilon]`\big{\rho}{\sigma}| gives
% $\Dmax[\epsilon]`\big{\rho}{\sigma}$.
% 
% The size-spec is as always given using the backtick syntax described in
% \autoref{topic:size-specification-backtick}.
%
% \DescribeMacro{\Dminz} The ``old'' min-relative entropy, based on the
% R\'enyi-zero relative entropy.  The syntax is the same as for
% |\Dmax|.
% 
% \DescribeMacro{\Dminf} The ``new'' min-relative entropy, defined using the
% fidelity.  The syntax is the same as for |\Dmax|.
%
% \DescribeMacro{\Dr} The Rob-relative entropy.  The syntax is the same as for
% |\Dmax|.
%
% \DescribeMacro{\DHyp} The hypothesis testing relative entropy.  The syntax is
% the same as for |\Dmax|, except that by default the optional argument is
% |\eta|.  That is, |\DHyp{\rho}{\sigma}| gives $\DHyp{\rho}{\sigma}$.  (This is
% because this quantity is directly defined with a $\eta$ (or $\epsilon$) built
% in, and it is not a zero-error quantity which is smoothed with the purified
% distance.)
%
% \DescribeMacro{\DDSym} The symbol to use to denote a relative entropy.  You
% may redefine this command to change the symbol.  (This works like |\HHSym|
% above.)
%
%
% \subsection{Coherent Relative Entropy}
% \label{sec:coh-rel-entr}
%
% A macro for a new quantity, the coherent relative entropy, is also available.
%
% \DescribeMacro{\DCoh}
% Typeset a coherent relative entropy.  The syntax is
% |\DCoh|\hspace{0pt}\oarg{epsilon}\hspace{0pt}\meta{size-spec}\hspace{0pt}\marg{rho}\hspace{0pt}\relax
% \marg{A}\hspace{0pt}\marg{B}\hspace{0pt}\marg{Gamma-1}\hspace{0pt}\marg{Gamma-2}.
%
% For example, |\DCoh[\epsilon]{\rho}{A}{B}{\Gamma_A}{\Gamma_B}| gives
% $\DCoh[\epsilon]{\rho}{A}{B}{\Gamma_A}{\Gamma_B}$.
%
% The subscript |BA| is automatically added to the \meta{rho} argument.  If this
% is not desired, then begin the \meta{rho} argument with a star.  For example,
% |\DCoh{*\sigma_A\otimes\rho_B}{A}{B}{\Gamma_A}{\Gamma_B}| gives
% $\DCoh{*\sigma_A\otimes\rho_B}{A}{B}{\Gamma_A}{\Gamma_B}$.
% 
% The \meta{size-spec} is of course optional and follows the same syntax as
% everywhere else (\autoref{topic:size-specification-backtick}).
%
% \DescribeMacro{\emptysystem} Use the |\emptysystem| macro to denote a trivial
% system.  For example, |\DCoh{\rho}{X}{\emptysystem}{\Gamma}{1}| gives
% $\DCoh{\rho}{X}{\emptysystem}{\Gamma}{1}$.
% 
% \DescribeMacro{\DCSym} The symbol to use to denote a coherent relative
% entropy.  You may redefine this command to change the symbol.  (This works
% like |\HHSym| and |\DDSym| above.)
%
%
%
%
%
%
%
%
%
% \StopEventually{\clearpage\PrintChanges
%     \vspace{2cm plus 2cm minus 2cm}\PrintIndex}
%
% \section{Implementation}
%
% First, load dependent packages.  Toolboxes, fonts and so on.
%    \begin{macrocode}
\RequirePackage{calc}
\RequirePackage{etoolbox}
\RequirePackage{amsmath}
\RequirePackage{dsfont}
\RequirePackage{mathrsfs}
\RequirePackage{mathtools}
%    \end{macrocode}
%
% \subsection{Simple Symbols and Shorthands}
% 
% 
% \subsubsection{General Symbols}
%
% These symbols are documented in \autoref{sec:symbols}.
%
% \begin{macro}{\Hs}
%   Hilbert space.
%    \begin{macrocode}
\newcommand{\Hs}{\mathscr{H}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Ident}
%   Identity operator, $\Ident$.
%    \begin{macrocode}
\newcommand{\Ident}{\mathds{1}}
%    \end{macrocode}
% \end{macro}
% 
%
% \begin{macro}{\IdentProc}
%   Identity process.
%    \begin{macrocode}
\def\IdentProc{%
  \phfqit@parsesizearg\phfqit@IdentProc@maybeA%
}
\newcommand\phfqit@IdentProc@maybeA[1][]{%
  \def\phfqit@IdentProc@val@A{#1}%
  \phfqit@IdentProc@maybeB%
}
\newcommand\phfqit@IdentProc@maybeB[1][]{%
  \def\phfqit@IdentProc@val@B{#1}%
  \phfqit@IdentProc@arg%
}
\def\phfqit@IdentProc@arg#1{%
  \def\phfqit@IdentProc@val@arg{#1}%
%    \end{macrocode}
% 
% At this point, prepare the three arguments, each expanded exactly as they were when
% given to these macros, and delegate the formatting to |\phfqit@IdentProc@do|.
%    \begin{macrocode}
  \edef\@tmp@args{%
    {\expandonce{\phfqit@IdentProc@val@A}}%
    {\expandonce{\phfqit@IdentProc@val@B}}%
    {\expandonce{\phfqit@IdentProc@val@arg}}%
  }%
  \expandafter\phfqit@IdentProc@do\@tmp@args%
}
\def\phfqit@IdentProc@do#1#2#3{%
  \operatorname{id}_{#1\notblank{#2}{\to #2}{}}%
  \notblank{#3}{\expandafter\phfqitParens\phfqit@val@sizearg{#3}}{}%
}
%    \end{macrocode}
% \end{macro}
% 
%
%
% \begingroup\catcode`\^=12\relax
% \begin{macro}{\ee^...}
%   Macro for the exponential.
%    \begin{macrocode}
\def\ee^#1{e^{#1}} % we could imagine that in inlines, we replace this by exp()...
%    \end{macrocode}
% \end{macro}
% \endgroup
%
% \subsubsection{Math Operators}
%
% See user documentation in \autoref{sec:math-operators}.
%
% \needspace{6\baselineskip}
% \begin{macro}{\tr}
% \begin{macro}{\supp}
% \begin{macro}{\rank}
% \begin{macro}{\linspan}
% \begin{macro}{\spec}
% \begin{macro}{\diag}
%   Some common math operators.  Note that |\span| is already defined by \LaTeX{}, so we
%   resort to |\linspan| for the linear span of a set of vectors.
%    \begin{macrocode}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\supp}{supp}
\DeclareMathOperator{\rank}{rank}
\DeclareMathOperator{\linspan}{span}
\DeclareMathOperator{\spec}{spec}
\DeclareMathOperator{\diag}{diag}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\Re}
% \begin{macro}{\Im}
%   Also, alter the appearance of |\Re| and |\Im| to something more readable.
%    \begin{macrocode}
\let\phfqit@Re\Re
\DeclareMathOperator{\phfqit@Realpart}{Re}%
\renewcommand{\Re}{\phfqit@Realpart}
\let\phfqit@Im\Im
\DeclareMathOperator{\phfqit@Imagpart}{Im}%
\renewcommand{\Im}{\phfqit@Imagpart}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{Poly}
%
% \begin{macro}{\poly}
%   Poly symbol.
%   \iffalse meta-comment
%         \changed[v1.0-added-poly-command]{v1.0}{2015/05/22}{Added \phfverb\poly\space command}
%   \fi
%    \begin{macrocode}
\DeclareMathOperator{\poly}{poly}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Bits and Bit Strings}
% 
% See documentation in \autoref{sec:bits}
%
% \begin{macro}{\bit}
% \begin{macro}{\bitstring}
%   Bits and bit strings.
%    \begin{macrocode}
\newcommand\bit[1]{\texttt{#1}}
\newcommand\bitstring[1]{\phfqit@bitstring{#1}}
%    \end{macrocode}
% 
% The implementation of |\bitstring| needs some auxiliary internal macros.
%    \begin{macrocode}
\def\phfqit@bitstring#1{%
  \begingroup%
  \setlength{\phfqit@len@bit}{\maxof{\widthof{\bit{0}}}{\widthof{\bit{1}}}}%
  \phfqitBitstringFormat{\phfqit@bitstring@#1\phfqit@END}%
  \endgroup%
}
%    \end{macrocode}
% 
% The internal |\phfqit@bitstring@| macro picks up the next bit, and puts it
% into a \LaTeX{} |\makebox| on its own with a fixed width.
%    \begin{macrocode}
\def\phfqit@bitstring@#1#2\phfqit@END{%
  \makebox[\phfqit@len@bit][c]{\phfqitBitstringFormatBit{#1}}%
  \if\relax\detokenize\expandafter{#2}\relax%
  \else%
%    \end{macrocode}
%
% If there are bits left, then recurse for the rest of the bitstring:
%    \begin{macrocode}
    \phfqitBitstringSep\phfqit@bitstring@#2\phfqit@END%
  \fi%
}
\newlength\phfqit@len@bit
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\phfqitBitstringSep}
% \begin{macro}{\phfqitBitstringFormat}
%   Redefine these to customize the bit string appearance.
%    \begin{macrocode}
\newcommand\phfqitBitstringSep{\hspace{0.3ex}}
\newcommand\phfqitBitstringFormat[1]{\ensuremath{\underline{\overline{#1}}}}
\def\phfqitBitstringFormatBit{\bit}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \subsubsection{Logical Gates}
%
% See user documentation in \autoref{sec:gates}.
%
% \begin{macro}{\gate}
%   Generic macro to format a gate name.
%    \begin{macrocode}
\DeclareRobustCommand\gate[1]{\ifmmode\textsc{\lowercase{#1}}%
  \else{\rmfamily\textsc{\lowercase{#1}}}\fi}
%    \end{macrocode}
% \end{macro}
% 
% \needspace{5\baselineskip}
% \begin{macro}{\AND}
% \begin{macro}{\XOR}
% \begin{macro}{\CNOT}
% \begin{macro}{\NOT}
% \begin{macro}{\NOOP}
%   Some common gates.
%    \begin{macrocode}
\newcommand{\AND}{\gate{And}}
\newcommand{\XOR}{\gate{Xor}}
\newcommand{\CNOT}{\gate{C-Not}}
\newcommand{\NOT}{\gate{Not}}
\newcommand{\NOOP}{\gate{No-Op}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
%
% \subsubsection{Lie Groups \& Algebras}
%
% \needspace{7\baselineskip}
% \begin{macro}{\uu(N)}
% \begin{macro}{\UU(N)}
% \begin{macro}{\su(N)}
% \begin{macro}{\SU(N)}
% \begin{macro}{\so(N)}
% \begin{macro}{\SO(N)}
% \begin{macro}{\SN(N)}
%   Some Lie Groups \& Algebras.  See \autoref{sec:Lie-groups-algebras}
%    \begin{macrocode}
\def\uu(#1){\phfqit@fmtLieAlgebra{u}(#1)}
\def\UU(#1){\phfqit@fmtGroup{U}(#1)}
\def\su(#1){\phfqit@fmtLieAlgebra{su}(#1)}
\def\SU(#1){\phfqit@fmtGroup{SU}(#1)}
\def\so(#1){\phfqit@fmtLieAlgebra{so}(#1)}
\def\SO(#1){\phfqit@fmtGroup{SO}(#1)}
\def\SN(#1){\mathrm{S}_{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\phfqit@fmtLieAlgebra}
% \begin{macro}{\phfqit@fmtLieGroup}
%   Override these to change the appearance of the group names or algebra names.  The
%   argument is the name of the group or algebra (e.g. |su| or |SU|).
%    \begin{macrocode}
\def\phfqit@fmtLieAlgebra#1{\mathrm{#1}}
\def\phfqit@fmtGroup#1{\mathrm{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
%
%
%
% \subsection{Bra-Ket Notation}
%
% 
% \needspace{8\baselineskip}
% \begin{macro}{\ket}
% \begin{macro}{\bra}
% \begin{macro}{\braket}
% \begin{macro}{\ketbra}
% \begin{macro}{\proj}
% \begin{macro}{\matrixel}
% \begin{macro}{\dmatrixel}
% \begin{macro}{\innerprod}
%   Bras, kets, norms, some delimiter stuff.  User documentation in
%   \autoref{sec:bra-ket}.  
%    \begin{macrocode}
\DeclarePairedDelimiterX\ket[1]{\lvert}{\rangle}{{#1}}
\DeclarePairedDelimiterX\bra[1]{\langle}{\rvert}{{#1}}
\DeclarePairedDelimiterX\braket[2]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
}
\DeclarePairedDelimiterX\ketbra[2]{\lvert}{\rvert}{%
  {#1}\delimsize\rangle\hspace*{-0.25ex}\delimsize\langle{#2}%
}
\DeclarePairedDelimiterX\proj[1]{\lvert}{\rvert}{%
  {#1}\delimsize\rangle\hspace*{-0.25ex}\delimsize\langle{#1}%
}
\DeclarePairedDelimiterX\matrixel[3]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
  \hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#3}%
}
\DeclarePairedDelimiterX\dmatrixel[2]{\langle}{\rangle}{%
  {#1}\hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#2}%
  \hspace*{0.2ex}\delimsize\vert\hspace*{0.2ex}{#1}%
}
\DeclarePairedDelimiterX\innerprod[2]{\langle}{\rangle}{%
  {#1},\hspace*{0.2ex}{#2}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \subsection{Delimited Expressions}
% Delimited expressions are documented in \autoref{sec:delimited}.
% 
% \begin{macro}{\abs}
% \begin{macro}{\avg}
% \begin{macro}{\norm}
%   Other delimited expressions.
%    \begin{macrocode}
\DeclarePairedDelimiterX\abs[1]{\lvert}{\rvert}{{#1}}
\DeclarePairedDelimiterX\avg[1]{\langle}{\rangle}{{#1}}
\DeclarePairedDelimiterX\norm[1]{\lVert}{\rVert}{{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% 
% \begin{macro}{\phfqit@insideinterval}
%   Format the contents of an interval.  Utility for defining |\intervalc| and
%   friends.
%    \begin{macrocode}
\def\phfqit@insideinterval#1#2{{#1\mathclose{},\mathopen{}#2}}
%    \end{macrocode}
% \end{macro}
%
% \needspace{4\baselineskip}
% \begin{macro}{\intervalc}
% \begin{macro}{\intervalo}
% \begin{macro}{\intervalco}
% \begin{macro}{\intervaloc}
% Open/Closed/Semi-Open Intervals
%    \begin{macrocode}
\DeclarePairedDelimiterX\intervalc[2]{[}{]}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervalo[2]{]}{[}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervalco[2]{[}{[}{\phfqit@insideinterval{#1}{#2}}
\DeclarePairedDelimiterX\intervaloc[2]{]}{]}{\phfqit@insideinterval{#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
%
% \subsection{Tools for Entropy Measures and Other Qit Quantities}
%
% \subsubsection{Some Internal Utilities}
%
% \begin{macro}{\phfqit@parsesizearg}
%   Internal utility to parse size argument with the backtick specification
%   (\autoref{topic:size-specification-backtick}).
%
%   Parses a size argument, if any, and stores it into |\phfqit@val@sizearg|.
%   The value stored can directly be expanded as an optional argument to a
%   |\DeclarePairedDelimiter|-compatible command (see \pkgname{mathtools} package).
%
%   |#1| should be a command token.  It is the next action to take, after
%   argument has been parsed.
%    \begin{macrocode}
\def\phfqit@parsesizearg#1{%
  \begingroup%
  \mathcode`\`="0060\relax%
  \gdef\phfqit@val@sizearg{}%
  \def\phfqit@tmp@contwithsize{\phfqit@parsesizearg@withsize{#1}}%
  \@ifnextchar`{\phfqit@tmp@contwithsize}{\endgroup#1}%
}
\def\phfqit@parsesizearg@withsize#1`#2{%
  \def\phfqit@tmp@x{#2}%
  \def\phfqit@tmp@star{*}%
  \ifx\phfqit@tmp@x\phfqit@tmp@star%
    \gdef\phfqit@val@sizearg{*}%
    \def\phfqit@tmp@cont{\endgroup#1}%
    \expandafter\phfqit@tmp@cont%
  \else%
    \gdef\phfqit@val@sizearg{[#2]}%
    \def\phfqit@tmp@cont{\endgroup#1}%
    \expandafter\phfqit@tmp@cont%
  \fi%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\phfqitParens}
%   Simple parenthesis-delimited expression, with
%   |\DeclarePairedDelimiter|-compatible syntax.  For example,
%   \par |\phfqitParens|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb( \meta{content} \phfverb)}
%   \par |\phfqitParens*|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb\left\phfverb( \meta{content} \phfverb\right\phfverb)}
%   \par |\phfqitParens[\big]|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb\bigl\phfverb( \meta{content} \phfverb\bigr\phfverb)}
%
%    \begin{macrocode}
\DeclarePairedDelimiterX\phfqitParens[1]{(}{)}{#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\phfqitSquareBrackets}
%   Simple bracket-delimited expression, with
%   |\DeclarePairedDelimiter|-compatible syntax.  For example,
%   \par |\phfqitSquareBrackets|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb( \meta{content} \phfverb)}
%   \par |\phfqitSquareBrackets*|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb\left\phfverb( \meta{content} \phfverb\right\phfverb)}
%   \par |\phfqitSquareBrackets[\big]|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb\bigl\phfverb( \meta{content} \phfverb\bigr\phfverb)}
%
%    \begin{macrocode}
\DeclarePairedDelimiterX\phfqitSquareBrackets[1]{[}{]}{#1}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\phfqitCurlyBrackets}
%   Simple bracket-delimited expression, with
%   |\DeclarePairedDelimiter|-compatible syntax.  For example,
%   \par |\phfqitSquareBrackets|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb( \meta{content} \phfverb)}
%   \par |\phfqitSquareBrackets*|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb\left\phfverb( \meta{content} \phfverb\right\phfverb)}
%   \par |\phfqitSquareBrackets[\big]|\marg{content} \quad$\to$\quad
%   \fbox{\phfverb\bigl\phfverb( \meta{content} \phfverb\bigr\phfverb)}
%
%    \begin{macrocode}
\DeclarePairedDelimiterX\phfqitCurlyBrackets[1]{\{}{\}}{#1}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsubsection{Basic machinery for Entropy-like Notation Objects}
%
% See user documentation in \autoref{sec:entropy-measures}.
%
% \begin{macro}{\QitObject}
%   The argument is the entropic quantity type (or ``entropic quantity
%   driver''): one of |Hbase|, |Hfnbase|, |Dbase|, |DCbase|, or a custom driver.
%    \begin{macrocode}
\newcommand\QitObject[1]{%
  \begingroup
\message{DEBUG: \detokenize{\QitObject{#1}}}%
  \def\QitObj@args{}%
  \def\qitobjParseDone{\QitObj@proceedToRender{#1}}%
  \def\qitobjDone{\endgroup\QitObjectDone}%
  \csname QitObj@reg@#1@parse\endcsname%
}
\def\qitobjAddArg#1{%
  \appto\QitObj@args{{#1}}%
}
\def\qitobjAddArgx#1{%
  \expandafter\qitobjAddArg\expandafter{#1}%
}
\def\QitObj@proceedToRender#1{% internal
\message{DEBUG: Rendering #1|\detokenize\expandafter{\QitObj@args}|}%
  \expandafter\def\expandafter\x\expandafter{\csname QitObj@reg@#1@render\endcsname}%
  \expandafter\x\QitObj@args%
}
\def\QitObjectDone{}
\def\DefineQitObjectType#1#2#3{%
  \csdef{#1}{\QitObject{#1}}%
  \expandafter\robustify\csname #1\endcsname%
  \cslet{QitObj@reg@#1@parse}#2%
  \cslet{QitObj@reg@#1@render}#3%
}%
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Entropic Quantity Type: Entropy, Conditional Entropy}
%
% \begin{macro}{\HbaseParse}
%   Base parser macro for ``$H(A\mid B)$''-kind entropy measures.
%
%   USAGE:
%   |\Hbase|\marg{H-symbol}\hspace{0pt}\relax
%   \marg{subscript}\hspace{0pt}\relax
%   \meta{size-spec}\hspace{0pt}\oarg{state}\relax
%   \hspace{0pt}\oarg{epsilon}\hspace{0pt}\marg{target system}\hspace{0pt}\relax
%   \oarg{conditioning system}
%
%   The argument \meta{size-spec} is optional, and is documented in
%   \autoref{topic:size-specification-backtick}.  For example \meta{size-spec} =
%   |`*| or |`\Big|.
%
%   Examples: 
%   \par |\Hbase{}{\hat{H}}{\mathrm{max}}[\rho][\epsilon]{E}[X']|
%   \quad$\to$\quad
%   \fbox{$\Hbase{}{\hat{H}}{\mathrm{max}}[\rho][\epsilon]{E}[X']$}
%   \par |\Hbase{}{\hat{H}}{\mathrm{max}}`*[\rho][\epsilon]{\bigotimes_i E}[X']|
%   \quad$\to$\quad
%   \fbox{$\Hbase{}{\hat{H}}{\mathrm{max}}`*[\rho][\epsilon]{\displaystyle\bigotimes_i E}[X']$}
%   \par |\Hbase{\def\HbaseRenderSup{#1}{\boldsymbol{#1}}}{\hat{H}}{\mathrm{max}}|\hspace{0pt}\relax
%   |`\big[\rho][\epsilon]{E}[X']|
%   \quad$\to$\quad
%   \fbox{$\Hbase{\def\HbaseRenderSup{\boldsymbol}}{\hat{H}}{\mathrm{max}}`\big[\rho][\epsilon]{E}[X']$}
%   
% 
%   The |\HbaseParse| macro is responsible for parsing the arguments to
%   |\Hbase|.  We should parse the arguments using helper macros as needed,
%   adding rendering arguments with |\qitobjAddArg| or |\qitobjAddArgx|, and
%   then calling |\qitobjParseDone|.  The arguments are then automatically
%   provided as arguments to the |\HbaseRender| function.  We just have to make
%   sure we add the correct number of arguments in the correct order.
%   
%   The first three arguments are the mandatory arguments
%   \marg{H-symbol}\hspace{0pt}\marg{subscript}
%    \begin{macrocode}
\def\HbaseParse#1#2{%
  \qitobjAddArg{#1}%
  \qitobjAddArg{#2}%
  \phfqit@parsesizearg\HbaseParse@%
}
%    \end{macrocode}
% 
% Some helper macros are used to parse all the arguments properly.  First parse
% an optional \oarg{state} argument.  Also, store the delimiter size argument
% which |\phfqit@parsesizearg| has stored into |\phfqit@val@sizearg|.
%    \begin{macrocode}
\newcommand\HbaseParse@[1][]{%
  \qitobjAddArgx{\phfqit@val@sizearg}%
  \qitobjAddArg{#1}%
  \HbaseParse@@%
}
%    \end{macrocode}
% Then parse an optional \oarg{epsilon} argument, as well as a mandatory
% \marg{target system} argument.
%    \begin{macrocode}
\newcommand\HbaseParse@@[2][]{%
  \qitobjAddArg{#1}%
  \qitobjAddArg{#2}%
  \HbaseParse@@@%
}
%    \end{macrocode}
% Finally, parse an optional \oarg{conditioning system}.
%    \begin{macrocode}
\newcommand\HbaseParse@@@[1][]{%
  \qitobjAddArg{#1}%
  \qitobjParseDone%
}
%    \end{macrocode}
%
% \begin{macro}{\HbaseRender}
%   Render the entropy measure.
%   \par |#1| = ``$H$'' symbol to use (e.g. |H|)
%   \par |#2| = subscript (type of entropy, e.g. |\marthrm{min},0|)
%   \par |#3| = possible size argument to expand in front of parens command (one
%   of \emph{(empty)}, |*|, or |[\big]| using a standard sizing command)
%   \par |#4| = the state (e.g. |\rho|), may be left empty
%   \par |#5| = epsilon argument (superscript to entropy measure), if any, or
%   leave argument empty
%   \par |#6| = system to measure entropy of
%   \par |#7| = conditioning system, if any, or else leave the argument empty
%    \begin{macrocode}
\def\HbaseRender#1#2#3#4#5#6#7{%
\message{DEBUG: HbaseRender\detokenize{{#1}{#2}{#3}{#4}{#5}{#6}{#7}}}%
%    \end{macrocode}
%
%   Start with the entropy symbol (`H'), the subscript, and the superscript:
%    \begin{macrocode}
  \HbaseRenderSym{#1}_{\HbaseRenderSub{#2}}^{\HbaseRenderSup{#5}}
%    \end{macrocode}
% Render the contents of the entropy (parenthetic expression with system \&
% conditioning system), only if the system or conditioning system or state are
% not empty:
%    \begin{macrocode}
  \notblank{#4#6#7}{%
    \HbaseRenderContents{#3}{#6}{#7}%
%    \end{macrocode}
% Finally, add the state as subscript, if any:
%    \begin{macrocode}
    \HbaseRenderTail{#4}%
  }{}%
%    \end{macrocode}
% We're done.
%    \begin{macrocode}
  \qitobjDone%
}
%    \end{macrocode}
% \end{macro}
%
% \needspace{5\baselineskip}
% \begin{macro}{\HbaseRenderSym}
% \begin{macro}{\HbaseRenderSub}
% \begin{macro}{\HbaseRenderSup}
% \begin{macro}{\HbaseRenderContents}
% \begin{macro}{\HbaseRenderTail}
%   Macros to render different parts of the entropy measure.  By default, don't
%   do anything special to them (but this might be locally overridden in a
%   group\ldots)
%    \begin{macrocode}
\def\HbaseRenderSym#1{#1}%
\def\HbaseRenderSub#1{#1}%
\def\HbaseRenderSup#1{#1}%
\def\HbaseRenderTail#1{_{#1}}%
%    \end{macrocode}
%
% A useful token register.
%    \begin{macrocode}
\newtoks\Hbase@tmp@toks
\def\Hbase@addtoks#1\@Hbase@END@ADD@TOKS{%
  \Hbase@tmp@toks=\expandafter{\the\Hbase@tmp@toks#1}}%
%    \end{macrocode}
% Now we need to define the macro which formats the contents of the entropy.
% The arguments are |#1| = possible sizing argument, |#2| = system name, |#3| =
% conditioning system if any.
%    \begin{macrocode}
\def\HbaseRenderContents#1#2#3{%
%    \end{macrocode}
% We need to construct the parenthetic argument to the entropy, which we will
% store in the token register |\Hbase@tmp@toks|.  Start with system name:
%    \begin{macrocode}
    \Hbase@tmp@toks={#2}%
%    \end{macrocode}
% \ldots{} add conditional system, if specified:
%    \begin{macrocode}
    \notblank{#3}{%
      \Hbase@addtoks\mathclose{}\,\delimsize\vert\,\mathopen{}%
          #3%
          \@Hbase@END@ADD@TOKS%
    }{}%
%    \end{macrocode}
% The tokens are ready now. Prepare the argument to the command
% |\HbaseRenderContentsInnerParens| (normally just |\phfqitParens|), and go:
%    \begin{macrocode}
    \edef\tmp@args{\unexpanded{#1}{\the\Hbase@tmp@toks}}%
    \expandafter\HbaseRenderContentsInnerParens\tmp@args%
}
\def\HbaseRenderContentsInnerParens{\phfqitParens}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\Hbase}
%   Finally, we declare our base entropic quantity type:
%    \begin{macrocode}
\DefineQitObjectType{Hbase}{\HbaseParse}{\HbaseRender}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\Hfnbase}
%   Entropy function.  Usage: |\Hfnbase(x)|, |\Hfnbase`*(x)|, |\Hfnbase`\big(x)| $\to$
%   $\Hfnbase(x)$, $\Hfnbase`*(x)$, $\Hfnbase`\big(x)$.
%
%   We can use the same renderer as |\Hbase|, we just need a different parser.
%   The parser accepts the mandatory arguments
%   \marg{H-symbol}\marg{subscript}\marg{superscript}.
%    \begin{macrocode}
\def\HfnbaseParse#1#2#3{%
  \qitobjAddArg{#1}% H-sym
  \qitobjAddArg{#2}% sub
  \phfqit@parsesizearg{\HfnbaseParse@{#3}}%
}
\def\HfnbaseParse@#1(#2){%
  \qitobjAddArgx{\phfqit@val@sizearg}% size-arg
  \qitobjAddArg{}% state
  \qitobjAddArg{#1}% epsilon
  \qitobjAddArg{#2}% system--main arg
  \qitobjAddArg{}% cond system
\message{DEBUG: Hfnbase args are |\detokenize\expandafter{\QitObj@args}|}%
  \qitobjParseDone%
}
\DefineQitObjectType{Hfnbase}{\HfnbaseParse}{\HbaseRender}
%    \end{macrocode}
% \end{macro}
% 
%
% \subsubsection{Relative Entropies}
% 
% User documentation in \autoref{sec:relative-entropies}.
%
% \begin{macro}{\DDSym}
%   Symbol to use to denote a relative entropy.
%    \begin{macrocode}
\newcommand\DDSym{D}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\@DDbase@inner}
%   Internal macro to format the inner contents of a relative entropy.
%   \begingroup\makeatletter
%   \par |\@DDbase@inner{\rho}{\Gamma}| \quad$\to$\quad \fbox{$\@DDbase@inner{\rho}{\Gamma}$}
%   \endgroup
%
%   You can also specify the optional size specifier compatible with the
%   |\DeclarePariedDelimiter| syntax: |\@DDbase@inner*{\rho}{\Gamma}| and
%   |\@DDbase@inner[\big]{\rho}{\Gamma}|, for example.
%
%    \begin{macrocode}
\DeclarePairedDelimiterX\@DDbase@inner[2]{(}{)}{%
  #1\mathclose{}\,\delimsize\Vert\,\mathopen{}#2%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@DDbase}
%   Base macro for relative entropy macros.
%
%   USAGE:
%   |\@DDbase|\marg{D-symbol}\hspace{0pt}\marg{subscript}\hspace{0pt}\relax
%   \marg{superscript}\meta{size-spec}\marg{state}\marg{relative to state}
%   
%   The \meta{size-spec} may be either a backtick-style specification, or a star
%   or an optional argument (``|[\big]|'').
%
%   \begingroup\makeatletter
%   Examples:
%   \par|\@DDbase{DSYMBOL}{subscript}{superscript}{\rho}{\Gamma}|  \quad$\to$\quad
%   $\@DDbase{DSYMBOL}{subscript}{superscript}{\rho}{\Gamma}$, and similarly\\
%   |\@DDbase{DSYMBOL}{subscript}{superscript}*{\rho}{\Gamma}|,
%   |\@DDbase{DSYMBOL}{subscript}{superscript}[\big]{\rho}{\Gamma}|,
%   |\@DDbase{D-symbol}{subscript}{superscript}`*{\rho}{\Gamma}|,
%   |\@DDbase{D-symbol}{subscript}{superscript}`\big{\rho}{\Gamma}|.
%   \endgroup
%
%  This command is robust.
%
%    \begin{macrocode}
\def\@DDbase#1#2#3{%
  #1_{#2}^{#3}%
  \@DDbase@parsesize%
}
\robustify\@DDbase
\def\@DDbase@parsesize{%
  \@ifnextchar`\@DDbase@withsize\@DDbase@inner%
}
\def\@DDbase@withsize`#1{%
  \def\@tmp@arg{#1}%
  \def\@tmp@star{*}%
  \ifx\@tmp@arg\@tmp@star\relax%
    \def\tmp@cmd{\@DDbase@inner*}%
    \expandafter\tmp@cmd%
  \else%
    \def\tmp@cmd{\@DDbase@inner[#1]}%
    \expandafter\tmp@cmd%
  \fi%
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\DD}
%   (Usual) quantum relative entropy.  Actually this is more versatile, because
%   you can also specify subscript and superscript.
%    \begin{macrocode}
\DeclareRobustCommand\DD{%
  \def\DD@tmp@sub{}%
  \def\DD@tmp@sup{}%
  \DD@%
}
\def\DD@{%
  \@ifnextchar_\DD@parsesub\DD@@%
}
\def\DD@@{%
  \@ifnextchar^\DD@parsesup\DD@@@%
}
\def\DD@@@{% sub/super-scripts have been parsed, move on to rest of command
  \@DDbase{\DDSym}{\DD@tmp@sub}{\DD@tmp@sup}%
}
\def\DD@parsesub_#1{%
  \def\DD@tmp@sub{#1}%
  \DD@% continue parsing maybe another sub or superscript
}
\def\DD@parsesup^#1{%
  \def\DD@tmp@sup{#1}%
  \DD@% continue parsing maybe another sub or superscript
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\Dminz}
%   ``Old'' min-relative entropy, based on the R\'enyi-zero relative entropy.
%    \begin{macrocode}
\DeclareRobustCommand\Dminz[1][]{%
  \@DDbase{\DDSym}{\mathrm{min,0}}{#1}%
}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\Dminf}
%   Min-relative entropy (``new'' version).
%    \begin{macrocode}

%
% \Dminf{\rho}{\sigma}
% \Dminf[\epsilon]{\rho}{\sigma}
% \Dminf<states-spec>
% \Dminf[\epsilon]<states-spec>
%
% Where <states-spec>  =  <size-spec>{\rho}{\sigma}
%
% Where optional  <size-spec>  =  "`*"  or  "`\Big"
% 
\DeclareRobustCommand\Dminf[1][]{%
  \@DDbase{\DDSym}{\mathrm{min}}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Dmax}
%   Max-relative entropy.
%    \begin{macrocode}
\DeclareRobustCommand\Dmax[1][]{%
  \@DDbase{\DDSym}{\mathrm{max}}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\Dr}
%   Rob-relative entropy.
%    \begin{macrocode}
\DeclareRobustCommand\Dr[1][]{%
  \@DDbase{\DDSym}{\mathrm{r}}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\DHyp}
%   Hypothesis testing relative entropy.
%    \begin{macrocode}
\DeclareRobustCommand\DHyp[1][\eta]{%
  \@DDbase{\DDSym}{\mathrm{H}}{#1}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Coherent Relative Entropy}
% 
% See user documentation in \autoref{sec:coh-rel-entr}.
% 
% \begin{macro}{\DC@inner}
%   Format the contents of the coherent relative entropy.  This is simply a
%   |\DeclarePariedDelimiter|-style command.  The syntax is
%   |\DC@inner|\hspace{0pt}\marg{rho}\hspace{0pt}\marg{Gamma1}\hspace{0pt}\marg{Gamma2}, and
%   this typesets as $\bigl(\meta{rho}\big\Vert\meta{Gamma1},\meta{Gamma2}\bigr)$.
%    \begin{macrocode}
\DeclarePairedDelimiterX\DC@inner[3]{(}{)}{%
  #1\mathclose{}\,\delimsize\Vert\,\mathopen{}#2\mathclose{},\mathopen{}#3%
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DCSym}
%   Symbol to use for the coherent relative entropy
%    \begin{macrocode}
\newcommand\DCSym{\bar\DDSym}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\emptysystem}
%   Designates the trivial system (uses symbol for empty set).  It is important
%   to this, because of the automatic indexes set on the ``rho'' argument.
%    \begin{macrocode}
\def\emptysystem{\ensuremath{\emptyset}}
%    \end{macrocode}
% \end{macro}
% 
%
% \begin{macro}{\DCoh}
%   The Coherent Relative Entropy.
%
%   TODO: Use our generic size parser, don't duplicate code!
%
%   First part: read the first few arguments (epsilon superscript, optional size
%   specification).
%    \begin{macrocode}
\newcommand\DCoh[1][]{%
  \def\DC@tmp@sup{#1}%
  %\message{*********|\detokenize{#1}|*********}%
  \begingroup\mathcode`\`="0060\relax
  \DC@parsesize%
}
\def\DC@parsesize#1{%
  \gdef\DC@tmp@sizeargs{}%
  \ifstrequal{#1}{`}\DC@withsize{\endgroup\DC@rest{#1}}%
}
\def\DC@withsize#1{%
  %\message{*********\detokenize{#1}********}%
  \def\@tmp@arg{#1}%
  \def\@tmp@star{*}%
  \ifx\@tmp@arg\@tmp@star\relax%
    \gdef\DC@tmp@sizeargs{*}%
    \endgroup%
    \expandafter\DC@rest%
  \else%
    \gdef\DC@tmp@sizeargs{[#1]}%
    \endgroup%
    \expandafter\DC@rest%
  \fi%
}
%    \end{macrocode}
% 
% Read the rest and typeset the output.  |#1|=rho, |#2|=system-in,
% |#3|=system-out, |#4|=Gamma-in, |#5|=Gamma-out:
%    \begin{macrocode}
\def\DC@rest#1#2#3#4#5{%
  %\message{*********\detokenize{#1}|\detokenize{#2}|\detokenize{#3}%
  %    |\detokenize{#4}|\detokenize{#5}|********}%
  \def\DC@tmp@rho{\DC@fmtrhosub#1\DC@ENDSTATE{#2}{#3}}%
  \DCSym_{#2\to #3}^{\DC@tmp@sup}%
  \expandafter\DC@inner\DC@tmp@sizeargs{\DC@tmp@rho}{#4}{#5}%
}
%    \end{macrocode}
% 
% Read the following tokens until the marker |\DC@ENDSTATE|, and format this as
% a state with or without the automatic system subscripts (depending on if the
% argument starts with a `|*|').
%    \begin{macrocode}
\def\DC@fmtrhosub{%
  \@ifnextchar*\DC@fmtrhosub@nosub\DC@fmtrhosub@wsub%
}
\def\DC@fmtrhosub@nosub*#1\DC@ENDSTATE#2#3{%
  #1%
}
\def\DC@fmtrhosub@wsub#1\DC@ENDSTATE#2#3{%
  \begingroup%
    \let\emptysystem\relax%
    #1_{#3#2}%
  \endgroup%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Standard entropy measures}
%
%
% Now, provide some standard entropy measures.
%
% \needspace{4\baselineskip}
% \begin{macro}{\HH}
% \begin{macro}{\Hzero}
% \begin{macro}{\Hmin}
% \begin{macro}{\Hmaxf}
%   The definition of individual entropy macros just delegates to |\Hbase|
%   with the relevant subscript.
%    \begin{macrocode}
\def\HSym{H}
\def\HH{\Hbase{\HSym}{}}
\def\Hzero{\Hbase{\HSym}{\mathrm{max},0}}
\def\Hmin{\Hbase{\HSym}{\mathrm{min}}}
\def\Hmaxf{\Hbase{\HSym}{\mathrm{max}}}
\def\Hfn{\Hfnbase{\HSym}{}{}}
\let\Hfunc\Hfn% backwards compatibility
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \Finale
\endinput
